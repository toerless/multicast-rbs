<?xml version="1.0" encoding="utf-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc version 1.7.1 (Ruby 3.1.3) -->


<!DOCTYPE rfc  [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">

]>

<?rfc comments="yes"?>

<rfc ipr="trust200902" docName="draft-eckert-pim-rts-forwarding-01" category="exp" submissionType="IETF" tocInclude="true" sortRefs="true" symRefs="true">
  <front>
    <title abbrev="pim-rts">Stateless Multicast Replication with Segment Routed Recursive Tree Structures (RTS)</title>

    <author initials="T." surname="Eckert" fullname="Toerless Eckert" role="editor">
      <organization>Futurewei Technologies USA</organization>
      <address>
        <postal>
          <street>2220 Central Expressway</street>
          <city>Santa Clara</city>
          <code>CA 95050</code>
          <country>USA</country>
        </postal>
        <email>tte@cs.fau.de</email>
      </address>
    </author>
    <author initials="M." surname="Menth" fullname="Michael Menth">
      <organization>University of Tuebingen</organization>
      <address>
        <postal>
          <country>Germany</country>
        </postal>
        <email>menth@uni-tuebingen.de</email>
      </address>
    </author>
    <author initials="S." surname="Lindner" fullname="Steffen Lindner">
      <organization>University of Tuebingen</organization>
      <address>
        <postal>
          <country>Germany</country>
        </postal>
        <email>steffen.lindner@uni-tuebingen.de</email>
      </address>
    </author>

    <date year="2024" month="March" day="04"/>

    
    <workgroup>PIM</workgroup>
    

    <abstract>


<?line 170?>

<t>BIER provides stateless multicast in BIER domains using bitstrings to indicate receivers.
BIER-TE extends BIER with tree engineering capabilities. 
Both suffer from scalability problems in large networks as bitstrings are of limited size
so the BIER domains need to be subdivided using set identifiers so that possibly many
packets need to be sent to reach all receivers of a multicast group within a subdomain.</t>

<t>This problem can be mitigated by encoding explicit multicast trees in packet headers with
bitstrings that have only node-local significance. A drawback of this method is that
any hop on the path needs to be encoded so that long paths consume lots of header space.</t>

<t>This document presents the idea of Segment Routed Recursive Tree Structures (RTS), a unifying
approach in which a packet header representing a multicast distribution tree is constructed
from a tree structure of vertices ("so called Recursive Units") that support replication
to their next-hop neighbors either via local bitstrings or via sequence of next-hop neighbor
identifiers called SIDs.</t>

<t>RTS, like RBS is intended to expand the applicability of deployment for stateless
multicast replication beyond what BIER and BIER-TE support and expect: larger networks, less
operational complexity, and utilization of more modern forwarding planes
as those expected to be possible when BIER was designed (ca. 2010).</t>

<t>This document only specifies the forwarding plane but discusses possible architectural
options, which are primarily determined through the future definition/mapping to encapsulation
headers and controller-plane functions.</t>



    </abstract>



  </front>

  <middle>


<?line 197?>

<section anchor="introduction"><name>Introduction</name>

<t>Please see {#version01} for a summary of changes over the prior version of this document.</t>

<t>This draft expands on prior experimental work called "Recursive BitString Structure" (RBS)
for stateless multicast replication with source routed data structures in the
header of multicast data packets. Its changes and enhancements over RBS are a result from further
scalability analysis and further matching against different use cases. Its proposed design
also includes Proof of Concept work on high-speed, limited functionality programmable
forwarding plane engines in the P4 programming language.</t>

<t>RTS, like RBS is intended to expand the applicability of deployment for stateless
multicast replication beyond what BIER and BIER-TE support and expect: larger networks, less
operational setup complexity, and utilization of more flexible programmable forwarding planes
as those expected to be possible when BIER was designed (ca. 2010).</t>

<t>Unlike RBS, RTS does not
limit itself to a design that is only based on the use of local bitstrings but instead offers
both bitstring and SID based addressing inside the recursive tree structure to support
to allow more scalability for a wider range of use cases.</t>

</section>
<section anchor="overview"><name>Overview</name>

<section anchor="from-bier-to-rts"><name>From BIER to RTS</name>

<section anchor="example-topology-and-tree"><name>Example topology and tree</name>

<figure title="Example topology and tree" anchor="fig-ov-topo"><artwork><![CDATA[
          Src                         Src
           |                           ||
           R1                          R1
          /  \                       //  \\
         R2   R3                     R2   R3
        /  \ /  \                  //  \ /  \\
       R5  R6    R7                R5  R6    R7
      /  \ | \  /  \             // \\ | \ //  \\
    R8    R9  R10  R11          R8    R9  R10  R11
    |     |    |    |           ||    ||   ||   ||
   Rcv1 Rcv2  Rcv3 Rcv4        Rcv1 Rcv2  Rcv3 Rcv4

    Example Network            Example BIER-TE / RTS Tree,
      Topology               // and || indicate tree segments
]]></artwork></figure>

<t>The following explanations use above example topology in <xref target="fig-ov-topo"/> on the
left, and example tree on the right.</t>

</section>
<section anchor="ip-multicast"><name>IP Multicast</name>

<t>Assume a multicast packet is originated by Src and needs to be replicated and
forwarded to be received by Rcv1...Rcv4. In IP Multicast with PIM multicast
routing, router R1...R11 will have so-called PIM multicast tree state, especially
the intermediate routers R2...R7. Whenever an IP Multicast router has multiple
upstream routers to choose from, then the path election is based on routing
RPF, so the routing protocol on R9 would need to route Src via R5, and R10 would
need to route Src via R7 to arrive at the tree shown in the example.</t>

</section>
<section anchor="bier"><name>BIER</name>

<t>In stateless multicast forwarding with Bit Index Explicit Replication (BIER),
<xref target="RFC8279"/>, a packet has a header with a bitstring,
and each bit in the bitstring indicates one receiver side BIER router (BFER).</t>

<figure title="Example BIER bitstring" anchor="fig-ov-bier"><artwork><![CDATA[
[R8:5 R9:9 R10:11 R11:17] =

00001000001000001000000000000000000000000 
]]></artwork></figure>

<t>In <xref target="fig-ov-bier"/>, the term [Ri:bi...] (i=5,9,10,11; bi=5,9,11,17) indicates the routers "Ri"
that have their associated bit in the bitstring number "bi" set.  In this
example, the bitstring is assumed to be 42 bit long. The actual
length of bitstring supported depends on the header, such as <xref target="RFC8296"/>
and implementation. The assignment of routers to bits in this example is
random.</t>

<t>With BIER, there is no tree state in R2...R7, but the packet is forwarded
from R2 across these routers based on those "destination" bits bi and information of
the hop-by-hop IP routing protocol, e.g.: IS-IS or OSPF. The intervening
routers traversed therefore also solely depend on that routing protocols
routing table, and as in IP multicast, there is no guarantee that the
shown intermediate hops in the example picture are chosen if, as shown there
are multiple equal cost paths (e.g.: src via R10-&gt;R6-&gt;R3 and R10-&gt;R7-&gt;R3).</t>

<t>The header and hence bitstring size is a limiting factor for BIER and
any source-routing.  When the network becomes larger, not all receiver
side routers or all links in the topology can be expressed by this number
of bits. A network with 10,000 receivers for example would require at least
40 different bitstrings of 256 bits to represent all 
receiver routers with separate bits. In addition, the packet header needs
to indicate which of those 40 bitstrings is contained in the packet header.</t>

<t>When then receiver routers in close proximity in the topology are assigned
to different bitstrings, then the path to these receivers will need to
carry multiple copies of the same packet payload, because each copy is
required to carry a different bitstring. In the worst case, even as few
as 40 receivers may require still 40 separate copies, as if unicast was
used - because each of the 40 bits is represented in a different bitstring.</t>

</section>
<section anchor="bier-te"><name>BIER-TE</name>

<t>In BIER with Tree Engineering (BIER-TE), <xref target="RFC9262"/>, the bits in the bitstring do
not only indicate the receiver side routers, but also the intermediate links in the
topology, hence allowing to explicitly "engineer" the tree, for purposes such
as load-splitting or bandwidth guarantees on the tree.</t>

<figure title="Example BIER-TE bitstring" anchor="fig-ov-bierte"><artwork><![CDATA[
[R1R2:4 R2R5:10 R5R8:15 R5R9:16 R1R3:25 R3R7:32 R7R10:39 R7R11:42]

000100000100001100000000100000010000001001
]]></artwork></figure>

<t>In <xref target="fig-ov-bierte"/>, the list of [RxRy:bi...] indicates the set of
bits needed to describe the tree in <xref target="fig-ov-topo"/>, using the same
notation as in <xref target="fig-ov-bier"/>.</t>

<t>Each RxRy indicates one bit in the bitstring for the link Rx-&gt;Ry. The need to express
every link in a topology as a separate bit makes scaling even more challenging
and requiring more bitstrings to represent a network than BIER does, but
in result of this representation, BIER-TE allows to explicitly steer copies
along the engineered path, something required for services that provide
traffic engineering, or when non-equal-cost load splitting is required (without
strict guarantees).</t>

</section>
<section anchor="rts"><name>RTS</name>

<t>With Recursive Tree Structure (RTS) encoding, the concept of steered forwarding
from BIER-TE is modified to actually encode the tree structure in the header as
opposed to just one single "flat" bitstring out of a large number of such bitstrings (in a
large network). For the same tree as above, the structure
in the header will logically look as follows.</t>

<figure title="Example RTS structure with SIDs" anchor="fig-ov-rts"><artwork><![CDATA[
Syntax:
  RU  = SID { :[  NHi+ ] }
  NHi = SID
  SID = Ri

Example tree with SID list on R1:
  R1 :[ R2 :[ R5 :[ R8   ,R9   ]], R3 :[R7 :[R10,  R11]]]

Semantic:
  R1 replicates to neighbors R2, R3.
  R2 replicates to R5
  R3 replicates to R7
  ...

Encoding structure:
  1 byte SID always followed by
  1 byte length of recursive structure length (":[" in example)
    If no recursive structure follows, length is 0.

Example SID list serialization (decimal):

  R1 :[ R2 :[ R5 :[ R8   ,R9   ]], R3 :[ R7 :[R10,  R11 ]]]
   |  |  |  |  |  |  | |   | |      | |   | |   | |   | | 
   v  v  v  v  v  v  v v   v v      v v   v v   v v   v v

   ..........SIDs according to above example..........
   |     |     |     |     |        |     |     |     |
  01 16 02 06 05 04 08 00 09 00    03 06 07 04 10 00 11 00
      |     |     |    |     |        |     |     |     |
      ......................Length fields................

Tree with SID list on R2:
  R2 :[ R5 :[ R8   ,R9   ]]
]]></artwork></figure>

<t>In the example the simplified RTS tree representation in <xref target="fig-ov-rts"/>, Rx:[NH1,... NHn]
indicates that Rx needs to replicate the packet to NH1, NH2 up to NHn.
This [NH1,... NHn] list is called the SID-list.  Each NH can again be a "recursive" structure
Rx:[NH1',...NHn'], such as R5, or a leaf, such as R8, R9, Ro10, R11.</t>

<t>A simplified RTS serialization of this structure for the packet header is
also shown: Each router Ri is represented by am 8-bit SID i. The 
length of the following SID list, :[NHi,...NHn], is also encoded in one byte.
If no SID list follows, it is 00.</t>

<t>When a packet copy is made for a next-hop, only the relevant
part of the structure is kept in the header as shown for R2.</t>

<figure title="Example RTS structure with bitstrings" anchor="fig-ov-rts-bits"><artwork><![CDATA[
Example tree with bitstrings on R1:
  BS1 :[ BS2 :[ BS5 :[ BS8,  BS9  ]], BS3  :[BS7 :[BS10, BS11]]]

Example bitstring serialization (decimal):

   ....List of next-hops indicated by the BitStrings.........
   |       |    |       |     |        |      |       |     |
  R2,R3   R5   R8,R9   Rcv   Rcv      R7     R10,R11 Rcv   Rcv
   |       |    |       |     |        |      |       |     |
  06 16   02 06 05 04  01 00 01 00    02  06 06  04  01 00 11 00
      |       |     |      |     |         |      |      |     |
      ......................Length fields.......................

Example tree with bitstrings on R2:
  BS2 :[ BS5 :[ BS8,  BS9  ]]
]]></artwork></figure>

<t>Instead of enumerating for each router the list of next-hop
neighbors by their number (SID), RTS can also use a bitstring
on each router, resulting in a potentially more compact encoding.
Scalability comparison of the two encoding options is discussed later
in the document. Unlike BIER/BIER-TE bitstrings, each of these bitstring will be small,
as it only needs to indicate the direct neighbors of the router for which
the bitstring is intended.</t>

<t>In <xref target="fig-ov-rts-bits"/>, the example tree is shown with this 
bitstring encoding, also simplified over the actual RTS encoding.
BSi indicates the bitstring for Ri as an 8-bit bitstring.
On R8, R9, R10, R11 this bitstring has bit 1 set, which
is indicating that these routers should receive ("Rcv") and decapsulate
the packet.</t>


</section>
<section anchor="summary-and-benefits-of-rts"><name>Summary and Benefits of RTS</name>

<t>In BIER for large networks, even small number of receivers may
not fit into a single packet header, such as aforementioned when having 10,000
receiver routers with a bitstring size of 256. BIER always requires to
process the whole bitstring, bit-by-bit, so longer bitstrings may cause
issues in the ability of routers to process them, even if the actual length of
the bitstring would fit into processable packet header memory in the router.</t>

<t>In BIER-TE, these problems are even more pronounced because the bitstrings
now need to also carry bits for the intermediate node hops, which are
necessary whenever the path for a packet need to be explicitly predetermined
such as in traffic engineering and global network capacity optimization through
non-equal cost load-balancing, which in unicast is also a prime reason
for deployment of Segment Routing.</t>

<t>These scalability problems in BIER and BIER-TE can be reduced by intelligent
allocation of bits to bitstrings, but this requires global coordination, and
for best results good predictions of the most important required future multicast
trees.</t>

<t>In RTS, no such network wide intelligent assignment of addresses is required,
and any combination of receiver routers can be put into a single packet header
as long as the maximum size of the header is not exceeded (including of course
the intermediate nodes along the path).</t>

<t>Unlike Bier/BIER-TE, the RTS header can likely on many platforms be larger
than a BIER/BIER-TE bitstring, because the router never needs to examine every
bit in the  header, but only the (local) bitstring or list of SIDs for this router
itself and then for each copy to a neighbor, it only needs to copy the recursive structure
for that neighbor. The only significant limit for RTS in processing
is hence the maximum amount of bytes in a header that can be addressed.</t>

</section>
</section>
</section>
<section anchor="architecture"><name>Architecture</name>

<t>This version of the document does not specify an architecture for RTS.</t>

<t>The forwarding described in this document can allow different architectures,
also depending on the encapsulation chosen. The following high-level architectural
considerations and possible goals/benefits apply:</t>

<t>(A) If embedding RTS in an IP or IPv6 source-routing extension header, RTS can provide
source-routing to eliminate stateful (IP) Multicast hop-by-hop tree building protocols
such as PIM. This can be specifically attractive in use cases that previously used
end-to-end IP Multicast without a more complex P/PE architecture, such as enterprises,
industrial and other non-SP networks.</t>

<t>(B) The encoding of the RTS multicast tree in the packet header makes
it natural to think about RTS providing a multicast "Segment Routing" architecture
style service with stateless replication segments: Each recursive structure is an RTS segment.</t>

<t>This too can be a very attractive type of architecture to support, especially for networks
that already use MPLS or IPv6 Segment Routing for unicast. Nevertheless, RTS can also be beneficial
in SP networks not using unicast Segment Routing, and there are no dependencies
for networks running RTS to also support unicast SR, other than sharing architecture concepts.</t>

<t>(C) RTS naturally aligns with many goals and benefits of BIER and even more so BIER-TE,
which it could most easily supersede for better scalability and ease of operations.</t>

<t>In one possible option, the RTS header specified in this document could even replace the bitstring of the
BIER <xref target="RFC8296"/> header, keeping all other aspects of BIER/BIER-TE reusable. In such an
option, the architectural aspects of RTS would be derived and simplified from <xref target="RFC9262"/>,
similar to details described in <xref target="I-D.eckert-bier-cgm2-rbs-01"/>.</t>

</section>
<section anchor="specification"><name>Specification</name>

<section anchor="rts-encapsulation"><name>RTS Encapsulation</name>

<figure title="RTS encapsulation" anchor="fig-rts-encap"><artwork><![CDATA[
+----------+--------+------------+
| Encap    | RTS    | Next Proto |
| Header(s)| Header | Payload    |
+----------+--------+------------+
]]></artwork></figure>

<t>This document specifies the formatting and functionality of the 
"Recursive Tree Structure" (RTS) Header, which is assumed to be located in a packet
between some Encap Header and some Next Proto / Payload.</t>

<t>The RTS header contains only elements to support replication to next-hops,
not any element for forwarding to next-hop. This is left as a task for the Encap Header
so that RTS can most easily be combined with potentially multiple alternative
Encapsulation Header(s) for different type of network protocols or deployment use cases.
Common Encap Headers will also require an Encap Header specific description of the total length of the RTS Header.</t>


<t>In a minimum (theoretical) example, RTS could be used on top of Ethernet with an
ethertype of RTS+Payload, which indicates not only that an RTS Header follows, but also
the type of the Next Proto Payload.</t>

<t>See the encap discussions in <xref target="encap-discussions"/> for considerations regarding BIER
or IPv6 extension headers as Encap Headers.</t>

</section>
<section anchor="rts-addressing"><name>RTS Addressing</name>

<t>Addresses of next-hops to which RTS can replicate are called RTS Segment IDentifiers (SIDs).
This is re-using the terminology established by <xref target="RFC8402"/> to be agnostic of the addressing
of the routing underlay used for forwarding to next-hops and obtaining routing information
for those routing underlay addresses. Specifying an encapsulation for RTS requires specifying how
to map RTS SIDs to addresses of the addresses used by that (unicast) forwarding mechanism.</t>

<t>RTS SIDs are more accurately called RTS replication SIDs. They are assigned to RTS
nodes. When a packet is directed to a particular RTS SID of an RTS node it means that
that node needs then to process the RTS Header and perform replication according to it.</t>

<t>Using the SR terminology does not mean that RTS is constrained to be used
with forwarding planes for which (unicast) SR mappings exist: IPv6 and MPLS, but
it means that for other forwarding planes, mappings need to be defined.
For example, when using RTS with <xref target="RFC8296"/> encapsulation, and hence BIER addressing,
which is relying on 16-bit BFR-id addressing (especially the BFIR-id in the
<xref target="RFC8296"/> header), then RTS SIDs need to map to these BFR-ids.</t>

<t>If instead RTS is to be deployed with (only) an IPv6 extension header as the Encap Header,
then RTS SIDs need to be mapped to IPv6 SIDs.</t>

<t>This document uses three types of RTS SIDs to support three type of encoding
of next-hops in an RTS Header: Global, Local and Local bitstring RTS SIDs.</t>

<t>All SIDs map to a unicast address or unicast SID of the node which the RTS SID addresses.
This unicast address or SID is used in an Encap Header when sending an RTS
packet to that node.</t>

<t>SIDs can be local or global in scope. All nodes only have one RTS SID table,
and it is purely a matter or the semantic assigned to a SID whether it is local or global
(as it is in SR).</t>

<t>There are two encoding lengths for SIDs, 10 and 18 bit. It may hence be beneficial
to fit all local SID into the lower 10 bit of the SID address table so they can
use the so-called short SID encoding (10 bit).</t>

<t>The network is expected to make SID information available to the creators of RTS headers so they can
create one or more RTS headers to achieve the desired replication tree(s) for a payload. This includes:</t>

<t><list style="symbols">
  <t>global SIDs and the nodes they map to.</t>
  <t>Semantic of local SIDs on each node to optimize RTS headers by use of local SIDs</t>
  <t>Capabilities of each node to understand which subset of the RTS syntax can be encoded in the so-called "Recursive Unit" for this node.</t>
  <t>For each node its "all-leaf-neighbors" list of global SIDs (see {#all-leaf-neighbors})</t>
</list></t>

</section>
<section anchor="rts-header"><name>RTS Header</name>

<figure title="RTS Header" anchor="fig-rts-header"><artwork><![CDATA[
+--------------------------------------------+ 
| RU0                                        |
|+---------++--------++-------+     +-------+|
||RU-Params|| RU-NH1 ||RU-NH2 | ....|RU-NHn ||
|+---------++--------++-------+     +-------+|
|           |<------- RU-list (optional) -->||
+--------------------------------------------+
]]></artwork></figure>

<t>The RTS Header consists of a recursive structure of "Recursive Units" abbreviated "RU"s.
The whole header itself is called RU0. Every RU is composed of RU-Params and an
optional list of RU for next-hops called the RU-list.</t>

<section anchor="ru-params"><name>RU-Params</name>

<figure title="RU-Format" anchor="fig-ru-format"><artwork><![CDATA[
 0 1 2 3 4 5                 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7   BSL * 8    rle(RULL)
+-+-+-+-+-+-+- ............ +- ........... -+- ........... -+- ....... -+- ...
|b|d|S|L|B|R| SID (3/10/18) | RULL (0/8)    |    BSL  | SD  | BitString | RU-List
+-+-+-+-+-+-+- ............ +- ........... -+- ........... -+- ....... -+- ...
 |<-Flags ->|
]]></artwork></figure>

<t>Flags:</t>

<t>b)roadcast: The node should broadcast copies of this packet to all direct leaf neighbors if set to 1, else not</t>

<t>d)eliver: The node should receive a copy of the packet itself if set to 1, else not.</t>

<t>S)ID: A SID is present if set to 1, else not. If no SID is present, the flags are followed by pad bits so that the following field will start at a byte boundary.</t>

<t>L)ength: The SID is "Long" (18 bit), else short (10 bit).</t>

<t>B)itString: If set to 1, a BitString is present as well as the BLE/SD fields, else all three fields are not present.</t>

<t>R)U-List: An RU-List and its length field, the RULL are present. If 0, both are not present.</t>

<t>SIDs:</t>

<t>As described by the S)ID and L)ength flags, when present, the SID can be 10 or 18 bit long.
These are called "short" and "long" SIDs. They both address the same single SID table
in the node. Short SIDs are just an encoding optimization. Any SID may be "local" or
"global". A SID is "global" when it points to the same node consistently. It is "local"
when each node has it's own, potentially different meaning for it. Typically, SIDs
fitting into a short SID will preferably be local SIDs such as those pointing to direct
(subnet) neighbors.</t>

<t>BitString / BSL / SD:</t>

<t>The BitString Length field (BSL) indicates the length of the BitString field in bytes.
It permits length of 0-32 bytes. SD is a SubDomain, and allows up to 8 different
BitStrings for each length.</t>

<t>RU-List / RULL:</t>

<t>RU-List Length (RULL) is the length of the RU-List field. To allow RU-Lists longer than
256 bytes, the encoding of RULL uses a simple encoding: RULL values &lt;= 127 indicate the
length of RU-List in bytes, values &gt;= 128 indicate a length of (127 + (RULL - 127) * 4).
This allows RU-List length of up to 640 bytes at the expense of up to 3 padding
bytes at the end of an RU-List required when encoding RU-Lists with length &gt; 127 bytes.</t>

<t>Note: RULL is placed before BSL/SD and BitString so that the offset of RULL inside of RU
is fixed and does not depend on the length of BitString (if present). This is beneficial
because both SID and RULL need to be parsed by prior-hop nodes when this RU is in
an RU-list. See the following explanations for more details.</t>

</section>
<section anchor="ru-params-parsing-and-semantics"><name>RU-Params Parsing and Semantics</name>

<t>An RU representing some specific nodeRU is parsed up to two times. The first time,
the RU may be present in the RU-List of the prior-hop node to nodeRU, and the second
time it is parsed by nodeRU itself.</t>

<section anchor="bitstring-replication-to-leaf-nodes"><name>Bitstring replication to leaf nodes</name>

<t><xref target="fig-ru-example1"/> shows the most simple example with bitstrings, the RU for a node
that should use a local BitString to replicate to only lead nodes</t>

<figure title="BitString replication to leaf nodes" anchor="fig-ru-example1"><artwork><![CDATA[
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5  BSL * 8
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- ....... -+
|0|0|0|0|1|0|0|0|    BSL  | SD  | BitString |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- ....... -+
 b d S L B R p p
 |<-Flags ->|
]]></artwork></figure>

<t>We assume the node is just transit node, so the packet is neither to be broadcast to all
leaf neighbors nor received, hence b=0, d=0.</t>

<t>The RU has no SID, so S=0, L=0, and hence the flags are followed by padding bits set to 0.</t>

<t>B=1 indicates a bitstring follows and R=0 indicates that the RU has no RU-list, and hence no
RULL. If the node's packet parser requires any non-required field to be present, then those
would have to be included and set to 0.</t>

<t>Note that this RU can only be used if this is the the root of the tree or the prior
hop node was also replicating to this node via a BitString. If the prior hop node was
replicating via a SID-List, then this RU would include a SID, but that SID would be
ignored, because it was only included for the benefit of the prior hop node.</t>

<t>BSL and SD indicate the BitString and its length.</t>

<t>When the node replicates to the bits in the BitString, it operates pretty much like
BIER-TE, aka: each bit indicates an adjacency, most likely direct, subnet-local neighbors.
For every bit, a copy is being made.</t>

<t>For the copy to a leaf neighbor, the RTS packet is rewritten to a simple form shown in
<xref target="fig-ru-example1-1"/>.</t>

<figure title="RU for leaf" anchor="fig-ru-example1-1"><artwork><![CDATA[
 0 1 2 3 4 5 6 7 
+-+-+-+-+-+-+-+-+
|b|d|0|0|0|0|0|0|
+-+-+-+-+-+-+-+-+
 b d S L B R p p
 |<-Flags ->|
]]></artwork></figure>

<t>The whole RTS header consists of a single by RU indicating simply whether the receiving
node should b)roadcast and/or d)eliver the packet. Both bits are derived from the 
BIFT (Bit Index Forwarding Table) of the replicating node.</t>

</section>
<section anchor="sid-list-replication-to-leaf-nodes"><name>SID-list replication to leaf nodes</name>

<t>Replication to a list of SID on a node requires an RU
on the node as shown in <xref target="fig-ru-example2"/>.</t>

<figure title="RU-List replication to leaf nodes" anchor="fig-ru-example2"><artwork><![CDATA[
                   1                   2
 0 1 2 3 4 5 6 7 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ...........
|0|0|0|0|0|1|0|0| RULL (8)      | RU-List
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ...........
 b d S L B R p p
 |<-Flags ->|
]]></artwork></figure>

<t>The SIDs of nodes to replicate to are always inside the neighbors RU, hence
SID-list replication means replication with an RU-List and hence also 
an RULL field.</t>

<t>The b and d field for the replicating nodes RU itself determine only whether
it should also broadcast and/or receive the packet, so their setting is
irrelevant to the RU-List operation, so we assume in this example both are 0.</t>

<t>If the prior hop node was also replicating via an RU-List, this RU would also
require a SID, but if this node is the root of the tree or the prior hop
was replicating via a BitString, it does not require a SID. We show this
simpler case. S=0, L=0 mean that instead of a SID, there are just two
padding bits p before RULL.</t>

<t>Assume all the neighbors to replicate to are direct neighbors, so we encode 
local SIDs that fit into short, 10-bit long SIDs. In result, the RU-list
is a sequence of 16-bit long RUs, one each for each neighbor to replicate to,
as shown in <xref target="fig-ru-example2-1"/>. And if the neighbor was a couple of
hops in the network topology away, one would use a global SID, in which case
it likely might require a long SID encoding, and hence 24-bit for the RU.</t>

<figure title="Leaf-node RU with SID" anchor="fig-ru-example2-1"><artwork><![CDATA[
                     1
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0|1|1|0|0|0| SID (10)          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 b d S L B R
 |<-Flags ->|
]]></artwork></figure>

<t>When the packet with the neighbors RU reaches that neighor, the RU is RU0,
aka: the complete RTS header.</t>

<t>In this encoding, unlike the encoding of the prior version of this document,
the SID itself carries no other semantic than the node it is targeted for.</t>

<t>When RTS is used (like BIER) as a standalone L3 network layer, this means
that intermediate RTS capable, but not replicating nodes could simply
unicast forward the packet to the node indicated by the RU0, similar to
how loose hops operate in IPv6 with SRH. But that only works when the SID
of RU0 is a global SID. So the replicating node may want to rewrite the
SID in the RU to a global SID (including adjusting the length) when 
such a mode of operation is desirable. However, when operating RTS
inside of IPv6, this loose-hop role would be served by an outer IPv6
header, and the RTS header would become another routing header. And
the SID serves no value anymore, but can be replaced by a special value
such as 0, or the RU be rewritten to not include a SID but just 2 bits
of padding.</t>

<t>Likewise, if the SID used in the RU encoding is a local SID, then its
semantic will likely be different on the receiving node, so if its
needed for loose hop routing, it would need to be rewritten to a global SID.
If used inside IPv6 or another network layer, local SIDs in RU0 should be
removed or replaced by 0.</t>

</section>
<section anchor="ru-with-sid-list-and-bitstring"><name>RU with SID-List and BitString</name>

<t>When would an RU require a SID and a BitString ? This is exactly
the case when the prior-hop node was replicating based on RU-List,
because this requires a SID in the next-hop RU, but that next-hop RU
itself should replicate with a BitString. In this case, the RU for
that node would include both a SID for the benefit of processing by
the prior-hop node, and a BitString (including BSL/SD) for its own
replication.</t>

<t>As mentioned before, the SID itself has no relevance anymore after
having been processed by the prior-hop replication engine, and might
be removed in the packet copy to the target node, but in the packet header
as encoded in the packet header for the root of the RTS tree, both SID and
BitString would need to be in the RU.</t>

</section>
<section anchor="bitstring-replication-to-non-leaf-neighbors"><name>BitString replication to non-leaf neighbors</name>

<t>When replicating to non-leaf neighbors via BitString, an RU-List parameter
is necessary in the RU of the replicating node. Which raises the question,
how the replicating node can know whether to replicate to a leaf or a
non-leaf neighbor.</t>

<t>There are two options for this:</t>

<t><list style="numbers">
  <t>In the BIFT of the replicating node, each bit has a flag indicating
whether or not the node indicated by the bit is always a leaf node
or potentially also a non-leaf node. In this option, there needs
to be an RU-list in the RU with an entry for each bit set in the
BitString that indicates to not always be a lead node in the BIFT.
Each such RU-list entry can be a simple 8-bit RU without SID or
BitString when that neighbor is addressed without the need for
a larger RU.</t>
  <t>There is no such bit in the BIFT, then all neighbors always
require an RU, which equally can be as short as 8-bit.</t>
</list></t>

</section>
<section anchor="functional-subsets-on-individual-nodes"><name>Functional subsets on individual nodes</name>

<t>Less capable forwarding engines may support only a subset of the encoding
and then need to be able to discover from the flag-bits whether the
RU destined for it contains an unsupported option and then stop processing
the packet and raise an error, e.g.: ICMP.</t>

<t>One set of limitations that seems to be necessary to fit functionally
limited forwarding engines could include all or a subset of the following:</t>

<t>o Only one size of SID can be supported. In this case, the long SID
  format should be supported, unless the type of device is known to
  always be leaf nodes in topologies, in which case only short SIDs may be
  supported.</t>

<t>o The variability of including an RU-list can not well be supported.
  In this case, the RU for such a node may need to always include
  a RUST field with a value of 0.</t>

<t>o The node can not support BitString replication for non-leaf neighbors.
  In this case, the RU with a BitString may not have the R-bit set and no
  RU-List. For common cases where this would be an issue, workarounds
  may be devised, for example, the node may have a local SID pointing
  back to it, so that the node needs to be encoded as 2 RU: The first
  RU uses RU-List replication, and one of the RU is for the local SID
  of the node itself, causing the packet to recirculate, and that
  RU would then use a BitString (without RU-List).</t>

<t>Because there are no "global" aspects to the parsing of RUs, it limitations
on one type of node only have limited impact on the network-wide ability
to construct tree.</t>

</section>
</section>
<section anchor="creating-and-receiving-copies"><name>Creating and Receiving copies</name>

<t>RTS relies on unicast forwarding procedures using the Encap Header(s) 
to receive packets and send copies of packets. Every copy of a packet created,
except for those that are for local reception by a node, is sent towards a unicast address/SID
according to the RTS SID it addresses.</t>

<t>The RU0 Flags are responsible for distinguishing the encoding of the following
RU parameters but also provides the bits used for processing by so-called "leaves" of an
RTS tree, where packets need to be delivered and/or broadcast to all "leaf" neighbors (where
they are then delivered).</t>

</section>
<section anchor="dcopy"><name>Creating copies because of RTS Header d=1</name>

<t>When d=1 is encountered in RU0, an (internal) copy of the packet is created
in which the headers up to the RTS Header are disposed of according to the procedures specified
for Encap Header(s) so that the Next Proto Payload after the RTS Header is processed.</t>

</section>
<section anchor="all-leaf-neighbors"><name>Creating copies because of RTS Header b=1</name>

<t>When b=1 is set in RU0 flags, a list of unicast addresses/SIDs called the
"all leaf neighbors" is used to create a separate copy of the packet for each element
in that list.  Each RTS node MAY have such a list.</t>

<t>For each packet copy made because of b=1, the RU0 for that neighbor is set with all
Flags to 0 except for d=0. The RU0 for each such neighbor is thus 8 bit long.
Typically, the "all-leaf-neighbors" list is (auto-)configured with the list of
RTS L2 neighbors that are known to be leaves of the RTS domain.</t>

</section>
</section>
</section>
<section anchor="discussion"><name>Discussion</name>

<section anchor="encoding-efficiency-vs-decoding-challenges"><name>Encoding Efficiency vs. decoding challenges</name>

<t>One core challenge for RTS is encoding efficiency, aka: the size of
the header required to address a particular number of leaves. Or with
a defined maximum header size the maximum number of leaves that can be addressed.</t>

<t>One core encoding trick to increase encoding efficiency is to not indicate
the semantic of variable fields but derive encoding from prior field or
state knowledge.</t>

<t>One example for this is not to encode the length of a local bitstring but
assume that this bitstring length is consistently known between the processing
node and the node encoding the bitstring, such as ingress-PE, controller or sender
application.</t>

<t>Consistent understanding of such control plane information to correctly encode
packet headers already exists as a requirement in other headers, specifically
MPLS and SR-MPLS and SRv6/SRH. The semantic of labels/SID is not necessarily
global and static in nature but often also local and learned through control plane.
If that control plane information is inconsistent, then encoding nodes may
create incorrect headers that will be incorrectly processed.</t>

<t>For RTS, one additional challenge is when such consistent control plane information
implies the length of fields, such as in the bitstring example. To reduce the
problem space to what has been accepted in unicast solutions such as MPLS/SR,
it may hence be necessary to explicitly include lengths for all variable lengths
fields. But this is in the opinion of the authors an open issue to investigate
further.</t>

<t>It may be possible and beneficial to instead of expanding the size of headers
because of this issue, to look into control plane solutions to avoid this
requirement. This could be based on the following mechanisms:</t>

<t>o Packets are forwarded only as L2 unicast with explicit addressing of
  destinations to prohibit hop-by-hop mis-delivery. Such as using L2
  ethernet with globally unique L2 ethernet MAC destination addresses.
  This is what the solution currently assumes.</t>

<t>o Mechanisms to the control plane distributing the relevant information
  (such as lengths of bitstrings, semantics of SIDs) not only in an
  "eventual consistency" way, but in a "strict consistency" way. Aka:
  all nodes in the domain that can be addressed by RTS trees are known
  to have consistent control plane information relevant to the consistent
  encoding/decoding.</t>

<t>o Mapping this "strict consistency" encoding to a numeric "control plane version"
  value that can be carried as a new field in headers.</t>

<t>Such an approach may not be sufficient to answer all questions, such as
how to change control plane information upon planned topology changes,
but it should suffice to ensure that whoever encodes a packet can add
the "control plane version" field to the header, and any node potentially
parsing this header will have either consistent information or not accept
the indicated "control plane version".</t>

<t>Short of deriving on such a solution, the encoding will become longer due to
the need of explicitly including fields for the semantic of following fields.
The encoding described has a range of cases where this option is already
defined as an alternative.</t>

<t>Because of these additional, not currently standard control plane requirements,
this version of the document includes now all variable aspects explicitly in the
encoding.</t>

</section>
<section anchor="encap-discussions"><name>Encapsulation considerations</name>

<section anchor="comparison-with-bier-header-and-forwarding"><name>Comparison with BIER header and forwarding</name>

<t>The RTS header is equivalent to the elements of a BIER/BIER-TE header required for
BIER and BIER-TE replication.</t>

<t>(SI, SD, BSL, Entropy, Bitstring)</t>

<t>RTS currently does not specify an ECMP procedure to next-hop SIDs because it is part
of the (unicast) forwarding to next-hops, but not to RTS replication.</t>

<t>Note that this is not the same set of header fields as <xref target="RFC8296"/>, because
that header contains more and different fields for additional functionality, which RTS
would require to be in an Encap Header.</t>

<t>For the same reason, the RTS Header does also not include the <xref target="RFC8296"/> fields TC/DSCP
for QoS, OAM, Proto (for next proto identification) and BFIR-id. Note that BFIR-id is not
used by BIER forwarding either, but by BIER overlay-flow forwarding on BFIR and BFER.</t>

<t>Constraining the RTS header to only the necessary fields was chosen to make it most
easy to combine it with any desirable encapsulation header.</t>

<t>RTS could use <xref target="RFC8296"/> as an Encap Header and BIER/<xref target="RFC8296"/>
forwarding procedures, replacing only BIER bitstring replication to next-hop functionality
with RTS replication.</t>

<t>In this case, the RTS Header could take the place of the bitstring field in
the <xref target="RFC8296"/> header, using the next largest size allowed by BIER to fit the RTS header.
SI would be unused, and SD could be used to run RTS, BIER and even BIER-TE in parallel
through different values of SD, and all BIER forwarding procedures including ECMP to
next-hop SIDs could be used in conjunction with RTS replication.</t>

</section>
<section anchor="comparison-with-ipv6-extension-headers"><name>Comparison with IPv6 extension headers</name>

<t>The RTS header could be used as a payload of an an IPv6 extension header
as similarly proposed for RBS in <xref target="I-D.eckert-msr6-rbs"/>. Note that the RTS
header itself does not contain a simple length field that allows to completely
skip across it. This is done because such functionality may not be required
by all encapsulation headers / forwarding planes, or the format in which such
a length is expected (unit) may be different for different forwarding planes.
If required, such as when using the RTS header in an IPv6 extension header, then
such a total-length field would have to be added to the Encap Header.</t>

</section>
</section>
<section anchor="encoding-choices-and-complexity"><name>Encoding choices and complexity</name>

<section anchor="sid-vs-bitstrings-in-recursive-trees"><name>SID vs bitstrings in recursive trees</name>

<t>The use of SID-lists in the encoding is a natural fit when the target tree is one
that does not require replication on many of the hops through which it passes, such as
when doing non-equal-cost load-splitting, such as in capacity optimization in service provider
networks. In <xref target="RFC9262"/>, Figure 2, such an example is called an "Overlay" (tree). In the
SID list, each of the SID can easily be global, making it possible for a next-hop to be anywhere
in the network. While it is possible to also use global SIDs in a bitstring, the decision to
include any global (remote) SID as a bit in a bitstring introduces additional encoding size
cost for every tree, and not only the ones that would need this bit. This is also the
main issue of using such global SIDs in BIER-TE (where they are represented as forward_routed())
adjacencies.</t>

<t>When replicating to direct neighbors, SID lists may be efficient for sparse trees. In the
RTS encoding, up to 127 direct neighbors could be encoded in 8 bit for each SID, so it is
easy to compare the encoding efficiency to that of a bitstring. A router with 32
neighbors (assume leaf neighbors for simplicity) requires 32 bits to represent all possible neighbors,
if 4 or fewer neighbors need to receive a copy, a SID-list encoding requires equal or fewer
bytes to encode.</t>

<t>Use of the broadcast option is equally possible with SID-list or bitstrings. An
initial scalability test with such an option was shown in slide 6 of <xref target="RBSatIETF115"/>, but
not included in any prior proposed encoding option; a better analysis of this option is
subject to future work.</t>

<t>The ability of the RTS encoding to mix for the initial part(s) of a tree SID lists
and then for leaves or tail parts of the tree bitstrings specifically addresses the
common understanding that multicast trees typically are sparse at the root and may also be
more "overlay" type, but then tend to become denser towards the leaves. Even if there is
the opportunity to create more replications within the first hops of a tree, that
approach may often not result in the most costs-effective ("steiner") trees.</t>

</section>
<section anchor="limited-per-node-functionality"><name>Limited per-node functionality</name>

<t>The encoding proposed in this (version of the) draft is based on P4 development of
a reference proof of concept called SEET+. It does not exactly follow the encoding,
but attempts to generalize it to support both more flexible and more constrained
forwarding platforms.</t>

<t>Because in a recursive tree an individual node only needs to parse one part of the
tree that is designated for it, this type of encoding allows it to support different
flexible forwarding engines in the same network: The recursive units that are
to be parsed by a less flexible nodes forwarding engine simply can not use all
the possible options, but only those options possible on that forwarding engine.</t>

<t>To then support such a mix of forwarding engines, the following architectural
elements are necessary:</t>

<t><list style="numbers">
  <t>The control plane of every node needs to signal the subset of functionality
so that the place where the control plane constructs an RTS will know what
limitations it has.</t>
  <t>The forwarding plane of nodes not supporting full functionality needs to be able
to reliably recognize when the encoding utilizes a feature not supported, stop
parsing/replicating the packet and raise an error (ICMP or similar) as necessary.</t>
</list></t>

<t>For example, some type of forwarding engines could have the following set of
limitations.</t>

<t>The forwarding engine might not be possible to process the recursive bitstring
structure because there could be insufficient code space for both recursive SID and
recursive bitstring option. In this case the limitation would be that a bitstring
type RU to be processed by this node does have to be a leaf which is not followed by a
set of RU for downstream neighbors.</t>

<t>Consider such a node is located in a distribution ring serving as an aggregation node to
a large number of lead neighbors.  In this topological case, a local bitstring would be
ideal to indicate which of the leaf neighbors the packet has to be replicated. However,
the packet would equally need to be forwarded to the next ring neighbor, and that
ring neighbor would need its own RU. Which would not be directly supportable on
this type of node.</t>

<t>To handle this situation, such a limited functionality node would assign a local SID
to itself and trees that pass through this node would need to encode first a SID
type RU indicating the ring neighbor as well as the node itself. The RU for this
nodes SID itself would then be a local bitstring RU. Likely the node would then
also process the packet twice through so-called recirculation. In addition, this
approach increases the side of the RTS encoding.</t>

</section>
</section>
<section anchor="differences-over-prior-recursive-bitstring-rbs-encodings-proposal"><name>Differences over prior Recursive BitString (RBS) encodings proposal</name>

<t>The encoding for bitstrings proposed in this draft relies again on discarding of unnecessary RU
instead of using offset pointers in the header to allow parsing only the relevant RU.</t>

<t>Discarding unnecessary RU has the benefit, that the total size of the header
can be larger than if offset pointers where used. Forwarding engines have
a maximum amount of header that they can inspect. With offset pointers, the
furthest a node has to look into the RTS header is the actual size of the
RTS header. With discarding of unnecessary RU, this maximum size for inspection can
be significantly less than the maximum RTS header size. Consider the root of tree has two neighbors
to copy to and both have equal size RU, then this root of the tree only needs to
inspect up to the beginning of the second RU (the SID or bitstring in it).</t>

</section>
</section>
<section anchor="security-considerations"><name>Security considerations</name>

<t>TBD</t>

</section>
<section anchor="acknowledgments"><name>Acknowledgments</name>

<t>The local bitstrings part of this work is based on the design published by Sheng Jiang, Xu Bing, Yan Shen, Meng Rui, Wan Junjie and Wang Chuang {jiangsheng|bing.xu|yanshen|mengrui|wanjunjie2|wangchuang}@huawei.com, see <xref target="CGM2Design"/>.  Many thanks for Bing Xu (bing.xu@huawei.com) for editorial work on the prior variation of that work <xref target="I-D.xu-msr6-rbs"/>.</t>

</section>
<section anchor="changelog"><name>Changelog</name>

<section anchor="section"><name>-00</name>

<t>This version was derived from merging the <xref target="SEET"/> and RBS proposals (called BEET in the <xref target="SEET"/> presentation)
into a single encoding mechanism. SEET is a proposal for per-tree-hop replication with SID-Lists, RBS is a
proposal for replication with per-hop local BitStrings. Both embody the same idea
of Recursive Units to represent each hop in the tree, but the content of these
recursive Units is different whether SID-Lists or BitStrings are used.</t>

<t>Because the processing of recursive structures are directly impacted and limited by
the capabilities of forwarding planes, and because by the time of writing this -00 draft,
only separate SEET and separate RBS reference Proof Of Concept implementations existed,
this version does propose to support only separate trees: A tree only constructed
from SID-Lists, or a Tree only supported from local BitStrings. Each packet needs
to choose which format to use.</t>

</section>
<section anchor="version01"><name>-01</name>

<t>After -00 version, reference Proof Of Concept work was done to investigate whether it
was possible in a single forwarding plane to support trees that can have both SID-lists
and local BitStrings. The main reason for this was that supporting both options as
ships in the night turned out to be costing too much code space on limited forward
plane engines.</t>

<t>In result, the reference limited forwarding plane engine could be made to support
trees with a limited mix of SID-list replication and local BitStrings. Local BitStrings
could only be used on hops prior to leaves, e.g.: no further local BitString
replication was possible (single stage).</t>

<t>RTS -01 is now a proposal that generalizes on these PoC experiences by proposing
a format for recursive units that allows to implement the limited functionality
possible on limited capability forwarding engines, but that also allow to
implement arbitrary mixing of per-hop use of SID-List and BitString replication
on forwarding planes that are more capable. The encoding is also chosen so that
nodes can easily recognize if the packet embodies an encoding option not supported
by it and reject the packet.</t>

<t>In addition, the -00 version of RTS did embody a range of optimizations for shorter
encoding length by avoiding packet header fields that contain information such as
parameter length that could be assumed to be known by both the generator and
consumer of the header element (RU). This has been removed in this version of the
proposal and replaced by explicitly integrating all variable length field information
as well as other interpretation semantics explicitly into the header encoding.
This change is not necessarily the final conclusion of thi issue, but the document
lays out what other control plane requirements would first have to be built to
be able to have more compact encodings - and those requirements are not commonly
support by the most widely used control planes.</t>

</section>
</section>


  </middle>

  <back>


    <references title='Normative References' anchor="sec-normative-references">



<reference anchor="RFC6554">
  <front>
    <title>An IPv6 Routing Header for Source Routes with the Routing Protocol for Low-Power and Lossy Networks (RPL)</title>
    <author fullname="J. Hui" initials="J." surname="Hui"/>
    <author fullname="JP. Vasseur" initials="JP." surname="Vasseur"/>
    <author fullname="D. Culler" initials="D." surname="Culler"/>
    <author fullname="V. Manral" initials="V." surname="Manral"/>
    <date month="March" year="2012"/>
    <abstract>
      <t>In Low-Power and Lossy Networks (LLNs), memory constraints on routers may limit them to maintaining, at most, a few routes. In some configurations, it is necessary to use these memory-constrained routers to deliver datagrams to nodes within the LLN. The Routing Protocol for Low-Power and Lossy Networks (RPL) can be used in some deployments to store most, if not all, routes on one (e.g., the Directed Acyclic Graph (DAG) root) or a few routers and forward the IPv6 datagram using a source routing technique to avoid large routing tables on memory-constrained routers. This document specifies a new IPv6 Routing header type for delivering datagrams within a RPL routing domain. [STANDARDS-TRACK]</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="6554"/>
  <seriesInfo name="DOI" value="10.17487/RFC6554"/>
</reference>

<reference anchor="RFC8279">
  <front>
    <title>Multicast Using Bit Index Explicit Replication (BIER)</title>
    <author fullname="IJ. Wijnands" initials="IJ." role="editor" surname="Wijnands"/>
    <author fullname="E. Rosen" initials="E." role="editor" surname="Rosen"/>
    <author fullname="A. Dolganow" initials="A." surname="Dolganow"/>
    <author fullname="T. Przygienda" initials="T." surname="Przygienda"/>
    <author fullname="S. Aldrin" initials="S." surname="Aldrin"/>
    <date month="November" year="2017"/>
    <abstract>
      <t>This document specifies a new architecture for the forwarding of multicast data packets. It provides optimal forwarding of multicast packets through a "multicast domain". However, it does not require a protocol for explicitly building multicast distribution trees, nor does it require intermediate nodes to maintain any per-flow state. This architecture is known as "Bit Index Explicit Replication" (BIER). When a multicast data packet enters the domain, the ingress router determines the set of egress routers to which the packet needs to be sent. The ingress router then encapsulates the packet in a BIER header. The BIER header contains a bit string in which each bit represents exactly one egress router in the domain; to forward the packet to a given set of egress routers, the bits corresponding to those routers are set in the BIER header. The procedures for forwarding a packet based on its BIER header are specified in this document. Elimination of the per-flow state and the explicit tree-building protocols results in a considerable simplification.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="8279"/>
  <seriesInfo name="DOI" value="10.17487/RFC8279"/>
</reference>

<reference anchor="RFC8296">
  <front>
    <title>Encapsulation for Bit Index Explicit Replication (BIER) in MPLS and Non-MPLS Networks</title>
    <author fullname="IJ. Wijnands" initials="IJ." role="editor" surname="Wijnands"/>
    <author fullname="E. Rosen" initials="E." role="editor" surname="Rosen"/>
    <author fullname="A. Dolganow" initials="A." surname="Dolganow"/>
    <author fullname="J. Tantsura" initials="J." surname="Tantsura"/>
    <author fullname="S. Aldrin" initials="S." surname="Aldrin"/>
    <author fullname="I. Meilik" initials="I." surname="Meilik"/>
    <date month="January" year="2018"/>
    <abstract>
      <t>Bit Index Explicit Replication (BIER) is an architecture that provides optimal multicast forwarding through a "multicast domain", without requiring intermediate routers to maintain any per-flow state or to engage in an explicit tree-building protocol. When a multicast data packet enters the domain, the ingress router determines the set of egress routers to which the packet needs to be sent. The ingress router then encapsulates the packet in a BIER header. The BIER header contains a bit string in which each bit represents exactly one egress router in the domain; to forward the packet to a given set of egress routers, the bits corresponding to those routers are set in the BIER header. The details of the encapsulation depend on the type of network used to realize the multicast domain. This document specifies a BIER encapsulation that can be used in an MPLS network or, with slight differences, in a non-MPLS network.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="8296"/>
  <seriesInfo name="DOI" value="10.17487/RFC8296"/>
</reference>

<reference anchor="RFC9262">
  <front>
    <title>Tree Engineering for Bit Index Explicit Replication (BIER-TE)</title>
    <author fullname="T. Eckert" initials="T." role="editor" surname="Eckert"/>
    <author fullname="M. Menth" initials="M." surname="Menth"/>
    <author fullname="G. Cauchie" initials="G." surname="Cauchie"/>
    <date month="October" year="2022"/>
    <abstract>
      <t>This memo describes per-packet stateless strict and loose path steered replication and forwarding for "Bit Index Explicit Replication" (BIER) packets (RFC 8279); it is called "Tree Engineering for Bit Index Explicit Replication" (BIER-TE) and is intended to be used as the path steering mechanism for Traffic Engineering with BIER.</t>
      <t>BIER-TE introduces a new semantic for "bit positions" (BPs). These BPs indicate adjacencies of the network topology, as opposed to (non-TE) BIER in which BPs indicate "Bit-Forwarding Egress Routers" (BFERs). A BIER-TE "packets BitString" therefore indicates the edges of the (loop-free) tree across which the packets are forwarded by BIER-TE. BIER-TE can leverage BIER forwarding engines with little changes. Co-existence of BIER and BIER-TE forwarding in the same domain is possible -- for example, by using separate BIER "subdomains" (SDs). Except for the optional routed adjacencies, BIER-TE does not require a BIER routing underlay and can therefore operate without depending on a routing protocol such as the "Interior Gateway Protocol" (IGP).</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="9262"/>
  <seriesInfo name="DOI" value="10.17487/RFC9262"/>
</reference>

<reference anchor="RFC8200">
  <front>
    <title>Internet Protocol, Version 6 (IPv6) Specification</title>
    <author fullname="S. Deering" initials="S." surname="Deering"/>
    <author fullname="R. Hinden" initials="R." surname="Hinden"/>
    <date month="July" year="2017"/>
    <abstract>
      <t>This document specifies version 6 of the Internet Protocol (IPv6). It obsoletes RFC 2460.</t>
    </abstract>
  </front>
  <seriesInfo name="STD" value="86"/>
  <seriesInfo name="RFC" value="8200"/>
  <seriesInfo name="DOI" value="10.17487/RFC8200"/>
</reference>

<reference anchor="RFC8402">
  <front>
    <title>Segment Routing Architecture</title>
    <author fullname="C. Filsfils" initials="C." role="editor" surname="Filsfils"/>
    <author fullname="S. Previdi" initials="S." role="editor" surname="Previdi"/>
    <author fullname="L. Ginsberg" initials="L." surname="Ginsberg"/>
    <author fullname="B. Decraene" initials="B." surname="Decraene"/>
    <author fullname="S. Litkowski" initials="S." surname="Litkowski"/>
    <author fullname="R. Shakir" initials="R." surname="Shakir"/>
    <date month="July" year="2018"/>
    <abstract>
      <t>Segment Routing (SR) leverages the source routing paradigm. A node steers a packet through an ordered list of instructions, called "segments". A segment can represent any instruction, topological or service based. A segment can have a semantic local to an SR node or global within an SR domain. SR provides a mechanism that allows a flow to be restricted to a specific topological path, while maintaining per-flow state only at the ingress node(s) to the SR domain.</t>
      <t>SR can be directly applied to the MPLS architecture with no change to the forwarding plane. A segment is encoded as an MPLS label. An ordered list of segments is encoded as a stack of labels. The segment to process is on the top of the stack. Upon completion of a segment, the related label is popped from the stack.</t>
      <t>SR can be applied to the IPv6 architecture, with a new type of routing header. A segment is encoded as an IPv6 address. An ordered list of segments is encoded as an ordered list of IPv6 addresses in the routing header. The active segment is indicated by the Destination Address (DA) of the packet. The next active segment is indicated by a pointer in the new routing header.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="8402"/>
  <seriesInfo name="DOI" value="10.17487/RFC8402"/>
</reference>

<reference anchor="RFC8754">
  <front>
    <title>IPv6 Segment Routing Header (SRH)</title>
    <author fullname="C. Filsfils" initials="C." role="editor" surname="Filsfils"/>
    <author fullname="D. Dukes" initials="D." role="editor" surname="Dukes"/>
    <author fullname="S. Previdi" initials="S." surname="Previdi"/>
    <author fullname="J. Leddy" initials="J." surname="Leddy"/>
    <author fullname="S. Matsushima" initials="S." surname="Matsushima"/>
    <author fullname="D. Voyer" initials="D." surname="Voyer"/>
    <date month="March" year="2020"/>
    <abstract>
      <t>Segment Routing can be applied to the IPv6 data plane using a new type of Routing Extension Header called the Segment Routing Header (SRH). This document describes the SRH and how it is used by nodes that are Segment Routing (SR) capable.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="8754"/>
  <seriesInfo name="DOI" value="10.17487/RFC8754"/>
</reference>




    </references>

    <references title='Informative References' anchor="sec-informative-references">




<reference anchor="I-D.eckert-bier-rbs">
   <front>
      <title>Recursive BitString Structure (RBS) Addresses for BIER and MSR6</title>
      <author fullname="Toerless Eckert" initials="T. T." surname="Eckert">
         <organization>Futurewei Technologies USA</organization>
      </author>
      <author fullname="Michael Menth" initials="M." surname="Menth">
         <organization>University of Tuebingen</organization>
      </author>
      <author fullname="Xuesong Geng" initials="X." surname="Geng">
         <organization>Huawei 2012 NT Lab</organization>
      </author>
      <author fullname="Xiuli Zheng" initials="X." surname="Zheng">
         <organization>Huawei 2012 NT Lab</organization>
      </author>
      <author fullname="Rui Meng" initials="R." surname="Meng">
         <organization>Huawei 2012 NT Lab</organization>
      </author>
      <author fullname="Fengkai Li" initials="F." surname="Li">
         <organization>Huawei 2012 NT Lab</organization>
      </author>
      <date day="24" month="October" year="2022"/>
      <abstract>
	 <t>   This memo introduces a compact data-structure representation of
   multicast trees called &quot;Recursive Bitstring Structure&quot; (RBS) and its
   use for (stateless) forwarding of packets that include this structure
   in their header.  It is intended as an alternative to &quot;flat&quot;
   bitstring addresses as used in BIER and BIER-TE or possible
   forwarding plane variations such as MSR6.  RBS aims to improve
   performance and scalability over flat bitstrings and simplify
   operations.

   Operations is simplified because RBS does not require the use,
   management and optimization of network-wide configured address spaces
   BIFT-ID and SI and because one common RBS mechanism can replace flat
   bitstring addresses for both shortest-path forwarding and tree
   engineered forwarding.  It intends to improve performance by allowing
   multicast to sparse set of receivers in larger networks with fewer
   packets and it intends to improve scalability by requiring less BIFT
   state on routers.

	 </t>
      </abstract>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-eckert-bier-rbs-00"/>
   
</reference>


<reference anchor="I-D.eckert-bier-cgm2-rbs-00">
   <front>
      <title>Carrier Grade Minimalist Multicast (CGM2) using Bit Index Explicit Replication (BIER) with Recursive BitString Structure (RBS) Addresses</title>
      <author fullname="Toerless Eckert" initials="T. T." surname="Eckert">
         <organization>Futurewei Technologies USA</organization>
      </author>
      <date day="25" month="October" year="2021"/>
      <abstract>
	 <t>   This memo introduces the architecture of a multicast architecture
   derived from BIER-TE, which this memo calls Carrier Grade Minimalist
   Multicast (CGM2).  It reduces limitations and complexities of BIER-TE
   by replacing the representation of the in-packet-header delivery tree
   of packets through a &quot;flat&quot; BitString of adjacencies with a
   hierarchical structure of BFR-local BitStrings called the Recursive
   BitString Structure (RBS) Address.

   Benefits of CGM2 with RBS addresses include smaller/fewer BIFT in
   BFR, less complexity for the network architect and in the CGM2
   controller (compared to a BIER-TE controller) and fewer packet copies
   to reach a larger set of BFER.

   The additional cost of forwarding with RBS addresses is a slightly
   more complex processing of the RBS address in BFR compared to a flat
   BitString and the novel per-hop rewrite of the RBS address as opposed
   to bit-reset rewrite in BIER/BIER-TE.

   CGM2 can support the traditional deployment model of BIER/BIER-TE
   with the BIER/BIER-TE domain terminating at service provider PE
   routers as BFIR/BFER, but it is also the intention of this document
   to expand CGM2 domains all the way into hosts, and therefore
   eliminating the need for an IP Multicast flow overlay, further
   reducing the complexity of Multicast services using CGM2.  Note that
   this is not fully detailed in this version of the document.

   This document does not specify an encapsulation for CGM2/RBS
   addresses.  It could use existing encapsulations such as [RFC8296],
   but also other encapsulations such as IPv6 extension headers.

	 </t>
      </abstract>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-eckert-bier-cgm2-rbs-00"/>
   
</reference>


<reference anchor="I-D.eckert-bier-cgm2-rbs-01">
   <front>
      <title>Carrier Grade Minimalist Multicast (CGM2) using Bit Index Explicit Replication (BIER) with Recursive BitString Structure (RBS) Addresses</title>
      <author fullname="Toerless Eckert" initials="T. T." surname="Eckert">
         <organization>Futurewei Technologies USA</organization>
      </author>
      <author fullname="Bing Xu" initials="B." surname="Xu">
         <organization>Huawei Technologies (2012Lab)</organization>
      </author>
      <date day="9" month="February" year="2022"/>
      <abstract>
	 <t>   This memo introduces the architecture of a multicast architecture
   derived from BIER-TE, which this memo calls Carrier Grade Minimalist
   Multicast (CGM2).  It reduces limitations and complexities of BIER-TE
   by replacing the representation of the in-packet-header delivery tree
   of packets through a &quot;flat&quot; BitString of adjacencies with a
   hierarchical structure of BFR-local BitStrings called the Recursive
   BitString Structure (RBS) Address.

   Benefits of CGM2 with RBS addresses include smaller/fewer BIFT in
   BFR, less complexity for the network architect and in the CGM2
   controller (compared to a BIER-TE controller) and fewer packet copies
   to reach a larger set of BFER.

   The additional cost of forwarding with RBS addresses is a slightly
   more complex processing of the RBS address in BFR compared to a flat
   BitString and the novel per-hop rewrite of the RBS address as opposed
   to bit-reset rewrite in BIER/BIER-TE.

   CGM2 can support the traditional deployment model of BIER/BIER-TE
   with the BIER/BIER-TE domain terminating at service provider PE
   routers as BFIR/BFER, but it is also the intention of this document
   to expand CGM2 domains all the way into hosts, and therefore
   eliminating the need for an IP Multicast flow overlay, further
   reducing the complexity of Multicast services using CGM2.  Note that
   this is not fully detailed in this version of the document.

   This document does not specify an encapsulation for CGM2/RBS
   addresses.  It could use existing encapsulations such as [RFC8296],
   but also other encapsulations such as IPv6 extension headers.

	 </t>
      </abstract>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-eckert-bier-cgm2-rbs-01"/>
   
</reference>


<reference anchor="I-D.eckert-msr6-rbs">
   <front>
      <title>Recursive Bitstring Structure (RBS) for Multicast Source Routing over IPv6 (MSR6)</title>
      <author fullname="Toerless Eckert" initials="T. T." surname="Eckert">
         <organization>Futurewei Technologies USA</organization>
      </author>
      <author fullname="Xuesong Geng" initials="X." surname="Geng">
         <organization>Huawei 2012 NT Lab</organization>
      </author>
      <author fullname="Xiuli Zheng" initials="X." surname="Zheng">
         <organization>Huawei 2012 NT Lab</organization>
      </author>
      <author fullname="Rui Meng" initials="R." surname="Meng">
         <organization>Huawei 2012 NT Lab</organization>
      </author>
      <author fullname="Fengkai Li" initials="F." surname="Li">
         <organization>Huawei 2012 NT Lab</organization>
      </author>
      <date day="24" month="October" year="2022"/>
      <abstract>
	 <t>   This document defines an encoding and corresponding packet processing
   procedures for native IPv6 multicast source routing (MSR6) using a
   so-called &quot;Recursive Bitstring&quot; (RBS) address structure.

   The RBS address structure encodes the source-routed multicast tree as
   a tree of bitstrings.  Each router on the tree only needs to examine
   and perform replication for the one bitstring destined for it.

   The MSR6/RBS IPv6 extension header encoding and processing is modeled
   after that of unicast source routing headers, RFC6554 and RFC8754,
   and shares all elements that can be shared.  To support the RBS
   structure, it is replacing the &quot;Segments Left&quot; pointer to the next
   segment with two fields to point to the next sub-tree to parse.

	 </t>
      </abstract>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-eckert-msr6-rbs-01"/>
   
</reference>


<reference anchor="I-D.xu-msr6-rbs">
   <front>
      <title>RBS(Recursive BitString Structure) for Multicast Source Routing over IPv6</title>
      <author fullname="Bing Xu" initials="B." surname="Xu">
         <organization>Huawei</organization>
      </author>
      <author fullname="Xuesong Geng" initials="X." surname="Geng">
         <organization>Huawei</organization>
      </author>
      <author fullname="Toerless Eckert" initials="T. T." surname="Eckert">
         <organization>Futurewei Technologies</organization>
      </author>
      <date day="30" month="March" year="2022"/>
      <abstract>
	 <t>   This document defines a new type of segment: End.RBS, and the
   corresponding packet processing procedures over the IPv6 data plane
   for the MSR6(Multicast Source Routing over IPv6) TE solutions.


	 </t>
      </abstract>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-xu-msr6-rbs-01"/>
   
</reference>


<reference anchor="I-D.eckert-bier-cgm2-rbs">
   <front>
      <title>Carrier Grade Minimalist Multicast (CGM2) using Bit Index Explicit Replication (BIER) with Recursive BitString Structure (RBS) Addresses</title>
      <author fullname="Toerless Eckert" initials="T. T." surname="Eckert">
         <organization>Futurewei Technologies USA</organization>
      </author>
      <author fullname="Bing Xu" initials="B." surname="Xu">
         <organization>Huawei Technologies (2012Lab)</organization>
      </author>
      <date day="9" month="February" year="2022"/>
      <abstract>
	 <t>   This memo introduces the architecture of a multicast architecture
   derived from BIER-TE, which this memo calls Carrier Grade Minimalist
   Multicast (CGM2).  It reduces limitations and complexities of BIER-TE
   by replacing the representation of the in-packet-header delivery tree
   of packets through a &quot;flat&quot; BitString of adjacencies with a
   hierarchical structure of BFR-local BitStrings called the Recursive
   BitString Structure (RBS) Address.

   Benefits of CGM2 with RBS addresses include smaller/fewer BIFT in
   BFR, less complexity for the network architect and in the CGM2
   controller (compared to a BIER-TE controller) and fewer packet copies
   to reach a larger set of BFER.

   The additional cost of forwarding with RBS addresses is a slightly
   more complex processing of the RBS address in BFR compared to a flat
   BitString and the novel per-hop rewrite of the RBS address as opposed
   to bit-reset rewrite in BIER/BIER-TE.

   CGM2 can support the traditional deployment model of BIER/BIER-TE
   with the BIER/BIER-TE domain terminating at service provider PE
   routers as BFIR/BFER, but it is also the intention of this document
   to expand CGM2 domains all the way into hosts, and therefore
   eliminating the need for an IP Multicast flow overlay, further
   reducing the complexity of Multicast services using CGM2.  Note that
   this is not fully detailed in this version of the document.

   This document does not specify an encapsulation for CGM2/RBS
   addresses.  It could use existing encapsulations such as [RFC8296],
   but also other encapsulations such as IPv6 extension headers.

	 </t>
      </abstract>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-eckert-bier-cgm2-rbs-01"/>
   
</reference>

<reference anchor="RFC791">
  <front>
    <title>Internet Protocol</title>
    <author fullname="J. Postel" initials="J." surname="Postel"/>
    <date month="September" year="1981"/>
  </front>
  <seriesInfo name="STD" value="5"/>
  <seriesInfo name="RFC" value="791"/>
  <seriesInfo name="DOI" value="10.17487/RFC0791"/>
</reference>


<reference anchor="Menth23" >
  <front>
    <title>Efficiency of BIER Multicast in Large Networks</title>
    <author initials="D." surname="Merling" fullname="D. Merling">
      <organization></organization>
    </author>
    <author initials="T." surname="Stber" fullname="Thomas Stber">
      <organization></organization>
    </author>
    <author initials="M." surname="Menth" fullname="M. Menth">
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
  <seriesInfo name="IEEE" value="accepted for &quot;IEEE Transactions on Network and Service Managment&quot;"/>
  <seriesInfo name="preprint" value="&lt;https://atlas.cs.uni-tuebingen.de/~menth/papers/Menth21-Sub-5.pdf&gt;"/>
<annotation>preprint</annotation></reference>
<reference anchor="Menth23f" >
  <front>
    <title>Learning Multicast Patterns for Efficient BIER Forwarding with P4</title>
    <author initials="S." surname="Lindner" fullname="S. Lindner">
      <organization></organization>
    </author>
    <author initials="D." surname="Merling" fullname="D. Merling">
      <organization></organization>
    </author>
    <author initials="M." surname="Menth" fullname="M. Menth">
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
  <seriesInfo name="IEEE" value="in &quot;IEEE Transactions on Network and Service Managment&quot;, vol. 20, no. 2, June 2023"/>
  <seriesInfo name="preprint" value="https://atlas.cs.uni-tuebingen.de/~menth/papers/Menth22-Sub-2.pdf"/>
</reference>
<reference anchor="Menth21" >
  <front>
    <title>Hardware-based Evaluation of Scalable and Resilient Multicast with BIER in P4</title>
    <author initials="D." surname="Merling" fullname="D. Merling">
      <organization></organization>
    </author>
    <author initials="S." surname="Lindner" fullname="S. Lindner">
      <organization></organization>
    </author>
    <author initials="M." surname="Menth" fullname="M. Menth">
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
  <seriesInfo name="IEEE" value="in &quot;IEEE Access&quot;, &lt;https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=6287639&gt;, vol. 9, p. 34500 - 34514, March 2021, &lt;https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9361548&gt;"/>
</reference>
<reference anchor="Menth20h" >
  <front>
    <title>P4-Based Implementation of BIER and BIER-FRR for Scalable and Resilient Multicast</title>
    <author initials="D." surname="Merling" fullname="D. Merling">
      <organization></organization>
    </author>
    <author initials="S." surname="Lindner" fullname="S. Lindner">
      <organization></organization>
    </author>
    <author initials="M." surname="Menth" fullname="M. Menth">
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
  <seriesInfo name="IEEE" value="in &quot;Journal of Network and Computer Applications&quot; (JNCA), vol. 196, Nov. 2020"/>
  <seriesInfo name="preprint" value="https://atlas.informatik.uni-tuebingen.de/~menth/papers/Menth20h.pdf"/>
  <seriesInfo name="DOI" value="10.1016/j.jnca.2020.102764"/>
</reference>
<reference anchor="SEET" target="&lt;https://datatracker.ietf.org/meeting/118/materials/slides-118-bier-02-ietf118-bier-p4-02.pdf&gt;">
  <front>
    <title>P4 Tofino Implementation Experiences with Advanced Stateless Multicast Source Routing</title>
    <author initials="S." surname="Lindner" fullname="Steffen Lindner">
      <organization>University of Tuebingen</organization>
    </author>
    <author initials="M." surname="Menth" fullname="Michael Menth">
      <organization>University of Tuebingen</organization>
    </author>
    <author initials="T." surname="Eckert" fullname="Toerless Eckert">
      <organization>Futurewei Technologies USA</organization>
    </author>
    <date year="2023" month="November" day="01"/>
  </front>
</reference>
<reference anchor="CGM2Design" target="&lt;https://github.com/BingXu1112/CGMM/blob/main/Novel%20Multicast%20Protocol%20Proposal%20Introduction.pptx&gt;">
  <front>
    <title>Novel Multicast Protocol Proposal Introduction</title>
    <author initials="S." surname="Jiang" fullname="Sheng Jiang">
      <organization></organization>
    </author>
    <author initials="B. (Robin)" surname="Xu" fullname="Bing (Robin) Xu">
      <organization></organization>
    </author>
    <author initials="Y." surname="Shen" fullname="Yan Shen">
      <organization></organization>
    </author>
    <author initials="M." surname="Rui" fullname="Meng Rui">
      <organization></organization>
    </author>
    <author initials="W." surname="Junjie" fullname="Wan Junjie">
      <organization></organization>
    </author>
    <author initials="W." surname="Chuang" fullname="Wang Chuang">
      <organization></organization>
    </author>
    <date year="2021" month="October" day="10"/>
  </front>
</reference>
<reference anchor="CGM2report" target="&lt;https://raw.githubusercontent.com/network2030/publications/main/CENI_Carrier_Grade_Minimalist_Multicast_Networking_Test_Report.pdf&gt;">
  <front>
    <title>Carrier Grade Minimalist Multicast CENI Networking Test Report</title>
    <author >
      <organization></organization>
    </author>
    <date year="2022" month="August" day="01"/>
  </front>
</reference>
<reference anchor="RBSatIETF115" target="&lt;https://datatracker.ietf.org/meeting/115/materials/slides-115-bier-recursive-bitstring-structure-rbs-beyond-bierbier-te-00&gt;">
  <front>
    <title>RBS (Recursive BitString Structure) to improve scalability beyond BIER/BIER-TE, IETF115</title>
    <author initials="T." surname="Eckert" fullname="Toerless Eckert">
      <organization></organization>
    </author>
    <author initials="M." surname="Menth" fullname="Michael Menth">
      <organization></organization>
    </author>
    <author initials="X." surname="Gend" fullname="Xuesong Gend">
      <organization></organization>
    </author>
    <author initials="X." surname="Zhen" fullname="Xiuli Zhen">
      <organization></organization>
    </author>
    <author initials="R." surname="Meng" fullname="Rui Meng">
      <organization></organization>
    </author>
    <author initials="F." surname="Li" fullname="Fengkai Li">
      <organization></organization>
    </author>
    <date year="2022" month="November"/>
  </front>
</reference>


    </references>


<?line 1135?>

<section anchor="evolution-to-rts"><name>Evolution to RTS</name>

<t>The following history review of RBS explains key aspects of the road towards RTS and
how prior document work is included (or not) in this RTS work.</t>

<section anchor="research-work-on-bier"><name>Research work on BIER</name>

<t>Initial experience implementation with implementation of BIER in PE was
gained through "P4-Based Implementation of BIER and BIER-FRR for Scalable and Resilient Multicast", <xref target="Menth20h"/>,
from which experience was gained that processing of large BIER bitstring requires significantly
complex programming for efficient forwarding, as described in "Learning Multicast Patterns for Efficient BIER Forwarding
ith P4", <xref target="Menth23f"/>. Further evaluations where researched through 
"Hardware-based Evaluation of Scalable and Resilient Multicast with BIER in P4", <xref target="Menth21"/> and
"Efficiency of BIER Multicast in Large Networks", <xref target="Menth23"/>.</t>

</section>
<section anchor="initial-rbs-from-cgm2"><name>Initial RBS from CGM2</name>

<t>The initial, 2021 <xref target="I-D.eckert-bier-cgm2-rbs-00"/> introduces the concept of Recursive Bitstring
Forwarding (RBS) in which a single bitstring in a source routing header for stateless multicast
replication as introduced by BIER and re-used by BIER-TE is replaced by a recursive structure
representing each node of a multicast tree and in each node the list of neighbors to which to
replicate to is represented by a bitstring.</t>

<t>Routers processing this recursive structure do not need to process the whole structure, instead,
they only need to examine their own local bitstring, and replicate copies to each of the neighbors
for which a bit is set in the bitstring for this node. For each copy the recursive structure
is rewritten so that only the remaining subtree behind the neighbor remains in the packet header.
By only having to examine a "local" (and hence short) bitstring, RBS processing can arguably be
simpler than that of BIER/BIER-TE. By discarding the parts of the tree structure not needed
anymore, there is also no need to change bits in the bitstring as done in BIER/BIER-TE to avoid
loops.</t>

<t>This initial version of RBS encoding is based on a design originally called "Carrier
Grade Minimalist Multicast" (CGM2), and which started as a research project whose design is
summarized in <xref target="CGM2Design"/>. A vendor high-speed router implementation proof-of-concept was
done, as well as a wide-area proof-of-concept research network deployment, which was
documented for the 2022 Nanjing "6th future Network Development Conference". An english translation
of the report can be found at <xref target="CGM2report"/>.</t>

</section>
<section anchor="rbs-scalability-compared-to-bier"><name>RBS scalability compared to BIER</name>

<t>The 2022 <xref target="I-D.eckert-bier-cgm2-rbs-01"/> version of the document adds topology and testing
information about a simulation comparing RBS with BIER performance in a dense, high-speed network topology.
It is showing that the number of replications required to reach an increasing number of receivers does
grow slower with RBS than with BIER, because in BIER, it is necessary to send another packet copy from the
source whenever receivers in a different Set Identifier Bitstring (SI) are required, whereas
RBS requires to only create multiple copies of a packet at the source to reach more receivers
whenever the RBS packet header size for one packet is exhausted. The results of this simulation
are shown in slide 6 of <xref target="RBSatIETF115"/>.</t>

<t>While RBS with its explicit description of the whole multicast tree structure seems immediately
like (only) a replacement for BIER-TE, which does the same, but encodes it in a "flat"BIER
bitstring (and incurring more severe scalability limitations because of this), this simulation
shows that the RBS approach may also compete with BIER itself, even though this may initially
look counter-intuitive because information not needed in the BIER encoding - intermediate hops -
is encoded in RBS.</t>

<t>The scalability analysis also assumes one novel encoding optimization, indicating replication to
all leaf neighbors on a node. This allow to even further compact the RBS encoding for dense trees,
such as in applications like IPTV. Note that this optimization was not included in any of the
RBS proposal specifications, but it is included in this RTS specification.This optimization leads
to the actual reduction in packet copies sent for denser trees in the simulation results.</t>

</section>
<section anchor="discarding-versus-offset-pointers"><name>Discarding versus offset pointers</name>

<t><xref target="I-D.eckert-bier-rbs"/> re-focusses the work of the prior <xref target="I-D.eckert-bier-cgm2-rbs"/> to focus
only on the forwarding plane aspects, removing simulation results and architectural considerations
beyond the forwarding plane.</t>

<t>It also proposes one then considered to be interesting alternative to the encoding. Instead of
discarding unnecessary parts of the tree structure for every copy of a packet made along the
tree, its forwarding machinery instead uses two offset pointers in the header to point to the
relevant sub-structure for the next-hop, so that only a rewrite of these two pointers is needed.
This replicates the offset-rewrite used in unicast source-routing headers such as in IP,
<xref target="RFC791"/>, or IPv6, <xref target="RFC6554"/> and <xref target="RFC8754"/>.</t>

<t>Discussions about discarding vs. changing of offset since then seems to indicate that changing
offsets may be beneficial for forwarders that can save memory bandwidth when not having to rewrite
complete packet headers, such as specifically systems with so-called scatter-gather I/O,
whereas discarding of data is more beneficial when forwards do have an equivalent of
scatter/gather I/O, something which all modern high-speed routers seem to have, including
the platform used for validation of the approach described in this document.</t>

</section>
<section anchor="encapsulations-for-ipv6-only-networks"><name>Encapsulations for IPv6-only networks</name>

<t>Whereas all initial RBS proposal did either not propose specific encapsulations for
the RBS structure and/or discussed how to use RBS with the existing BIER encapsulation <xref target="RFC8296"/>,
the 2022 <xref target="I-D.xu-msr6-rbs"/> describes the encapsulation of RBS into an IPv6 extension header,
in support of a forwarding plane where all packets on the wire are IPv6 packets, rewriting
per-RBS-hop the destination IPv6 address of the outer IPv6 header like pre-existing
unicast IPv6 stateless source routing solutions too (<xref target="RFC6554"/>, <xref target="RFC8754"/>).</t>

<t>This approach was based on the express preference desire of IPv6 operators to have a common
encapsulation of all packets on the wire for operation reasons ("IPv6 only network design") and to share
a common source-routing mechanism operating on the principle of per-steering-hop IPv6
destination address rewrite.</t>

<t><xref target="I-D.eckert-msr6-rbs"/> extends this approach by adding the offset-pointer rewrite of
<xref target="I-D.eckert-bier-rbs"/> to the extension header to avoid any change in length of the
extension header, but it also includes another, RBS independent field, the IPv6 multicast
destination address to the extension header. Only this additional would allow for RBS
with a single extension header to be a complete IPv6 multicast source-routing solution.
BIER/BIER-TE or any encapsulation variations of RBS without such a header field would
always require to carry a full IPv6 header as a payload to provide end-to-end IPv6 multicast
service to applications.</t>

</section>
<section anchor="seet-and-beet"><name>SEET and BEET</name>

<t>To validate concepts for recursive trees, high-speed reference platform proof of concept
validation was done for booth SID-list and local-bitstring based recursive trees in 2023.
This is called in the research work SEET and BEET. See <xref target="SEET"/>. Paper to follow.</t>

</section>
</section>

    <section anchor="contributors" numbered="false" toc="include" removeInRFC="false">
        <name>Contributors</name>
    <contact initials="X." surname="Geng" fullname="Xuesong Geng">
      <organization>Huawei</organization>
      <address>
        <postal>
          <country>China</country>
        </postal>
        <email>gengxuesong@huawei.com</email>
      </address>
    </contact>
    <contact initials="X." surname="Zheng" fullname="Xiuli Zheng">
      <organization>Huawei</organization>
      <address>
        <postal>
          <country>China</country>
        </postal>
        <email>zhengxiuli@huawei.com</email>
      </address>
    </contact>
    <contact initials="R." surname="Meng" fullname="Rui Meng">
      <organization>Huawei</organization>
      <address>
        <postal>
          <country>China</country>
        </postal>
        <email>mengrui@huawei.com</email>
      </address>
    </contact>
    <contact initials="F." surname="Li" fullname="Fengkai Li">
      <organization>Huawei</organization>
      <address>
        <postal>
          <country>China</country>
        </postal>
        <email>lifengkai@huawei.com</email>
      </address>
    </contact>
    </section>

  </back>

<!-- ##markdown-source:
H4sIAAAAAAAAA9V963YbR5Lm/3yKXPjsDjAGQIC6c8Y9I0pUm30km0vS45lt
+/gUgAJRFlCFqSqQYluaJ9t/+2Ib18zIAiire3bPnlW7KQqoysqKjIzrF5Gj
0cjNq0VR3pz4XbscPXeuLdp1fuKv2qzN13nT+He7dVvMs6b1l/l2Db+1RVX6
u6Jd+av8ZpOX8EW1a/MFfD/f1U1xm/vrOs9hiHo3b3d13vj+5fXVwLtsNqvz
2xO/LTajum3copqX2QaetqizZTvK5+/zuh3Jt6NlVd9lNU5uNJm6O5jixfk7
B8/Pb6r6/sTnH7au2NYnHp7TtMeTyYvJsWvaOs82J/787PqNg39l5eKXbF2V
8JD7vHHb4sT/ua3mQ99UNVy6bOC3+w3/Mq82+DrNz85lu3ZV1SfO+xH8n/7w
TK+rvCaynNFk9cu6QqLli6Ktav2sqmHKb3ZIgbu88Nf5fFVW6+qmAIL8cPVS
L8MZ5+2JPz4+nvhX8Pw6W/uzD1ugW3OX3etl86KFd77Kyjbzr9ZZnYUvqgU8
+tVL/+LJ5MkkfrqDkeAO86R8kxVrIFeb//O8GS+z3XiR77/hu2K+yvK1fwdT
WSXv8kMJawsL3N77aumvd/kM1iYv9x75x7zeZOV957FI2tU/78pi1OqdB59/
1ebLZV76t0W5KPP6/+AMGh55vOaR9+cCewHuL2a7Ftd+JBP6113eVOUNDFre
OJnIt7sM1tSZR75aFSWuiTwLRrz5wDf+84ouHgN7xTGL3brw/2P11wz5F7z6
A954aMTLXYFL9uXDwXrc1LuDY72Br95nBSzBF4+2LpZ8kx3PubKChWhh0XAr
Xb559fTJk8fy6/PjZy/Cry+eyq8vjp8eh08nE/318SR8+gxHcEW5tEOfj16P
RXzMirwe1bPm0Mfzm80xfjfikR/+etr5etPUT+2gH3Z7Hx0aSOb87AWMB7/S
ljp+dEJ8KYL2bLks5kVezomlT8/PLo3ELWAbZPVN7r/L27uqft/QnVlZggyt
821dlCyBoriCP7qKr8fwwBqY/Sb9/HpVbbIG9tn/+p8z3V/63bux2fdNXoOs
QkqfeNlK52dnZyc+m8/zLUp8WAPfw89A4mdlk81RNzQe9INMGOa6ADVR3xbz
3L/LyowURk9G03c48f+4atttc3J0lLXrrBmDeOpuzqP/IAFytM22IAGOmJTT
0dVuNnoy3i6WfzAEXiYUfptndQnDGLpeZCAEa5gpvoCuQMvUfxPUDiu5i8cP
k/hqnIqp3yP9l5EXVv1vIerQ31brsT+eDH1Zwd9D/6ddmcO/jx/t0ftvI/cx
kfsYyR2pPU2I/S2QDsiXj2ZZAwxydputd2wxAHdfzbN1Nlvn9AKX8O5rIntc
FyI4rQLQ4HOEf4jADy3IQ4Q/TPeXwN9NAwQNbFnkOZgb66rOx/jrGITiEfz7
CEweGPa8aXb5+Ndm+0/bXbnbwK765unx82dPH734gyzKi6Hfjv2jx08mE5gT
/D19PISlq+crXJ/p7zwJzJjNln/SU9rtN/8NeJqf9OLR0+mTx88N/09WyZJc
PB6d0mKcb7brHJc1LAiRGhcDfxm9ubykDfF7y/T/YFn+VO3qEuwimLPdBK+q
zRZMz9q/3AbTtOn5/p++e/VyIKSfvng69N9Vt7gzjie/sxOCWnn/ZTtisqLN
wIO+/v78xE8n4+lk+vTo1/Gv5Twb4zPhg+NnTx/jAl2dnV13FgdMymVRVt3V
AQsQ6VECJ/K2eLm4zeBfi4Om+RXQB4QBGuJK/AVcdUK7fzSdogVNT0VtYuUt
XJWBxYm6C/itXRK/bcAghWGOptPnR0AMmEe2bo6adbHIGxjsOSu5yfEI7wj/
3j6Gj1gU7zFINPJ+x8z7IkNvb7CDNuvfNtQDBv7vm/Nw5as/vjt+DSx8UyZr
DMyHc4vap67ABanW+Mu2aoCtz8GmqhY7kvTp4k1H0wn8d3jxboAvdjM0tY5O
4aX+dTedTo+PYBbvjmbragZrV5RH9PT/ejwJz4ffdQb8K80BfrWzGG+37YfP
L6SsI1ql/k9FBj8fuATnBi5gBYQfgDX9wFX/lpU0mH7tO9+jcYtW7gO3/wi3
g777tcgfGuBHnOIrME9hg8higRQANzBZrFdZDduu9n+sswVo16IsNtm6aKyW
enX23bmKIXy165yd40rYJSze8Wjy/MGdV2d3Y17AHUg+9DyAeWktSx76ePJo
crTdzYJg4/XEp/8is/yFZvlLnOUvYZa/xAn+ghP8hScYTKXL06usRS95On2S
EAC+gMUKrvxp0YIjj68Z/PmBbytfbLY1cJZvSFmAioD9NcvvK1EmR6RRrs+G
Xp7Rpcz0bxNITw4JpCdi9Ouk4Z9tQ5MeNTppsut5gnQ13dHm4Al8CZcflgrd
qw6Joe41xptcPHRJcA4fuMD4eoe+Nu6bG41GPps1SNHWOdL3uG5IOPCHVZFs
rMdBFy0qZLbG7xpc+kDPhpa+XCBL5h4InpNwHTtZbp9/ADZeNDwI6S0Mb3iY
UVHmOfHRPNsyw4DkHHt3WsFFzQ6UQe2XdbVJOArmCobIpsF5rckTks3ReHBh
zLTA5ETxvi42BTomTfGX3DWVb1d5+j4wiQW+www4dzdbFEiJhbxlk8P7L2Dt
iiUwB9AH789aD/KxKWbre08xhS3yZpuOhOYR/FrnGRh02XodKYOTygx9b+pq
tyXCwBtlNAea2di561XR6AsDkUocGd6muMnwjWb3QESO1WHkC4RC0ZpxkcpE
JZ6eX+UgGGo2HZxdPnyhVQYbtyrhjcpqkY/WFVDco9qCF5+jkTH2LzEmdzeD
wfANWpzaJocdsvAFD+KAFn5VbdEvQSpvM1hGpEkjRKHZ4lIIFdfI9XhV40HY
NbtNDh+1RCCerG9g7rkSYlHNdxRcxEAYRuXoKbA8GXkSf1XkcQiUBnNueY+2
UbYFGuM6AbHuVgUuWEo0j7YhPRNpbRdvUTQcHkIDjfi64Jeh5+ULR/yb8VdB
8uB8gRVgDJxPD+gB5F4nswYbpW16AyZUs9uipMZpqOh3LbFyUQOFP7QjJHuZ
FzerWQVLnMMSw6xvi8zzSprlrvjzJv/3HZqSOJW9EZzleZna1flr2NQOiDeE
PfU+J61QIIPh9mbGBy5EGxyXJWPzWzYtPGQBc6/uaYnQowiSxkVimtdTxXGH
r5/6JCBSlB74GTwzn4O6IFlQB2EAk8TBKzCZaUAgAihSsKc/wHyGdCcs2rr4
S/B8NuBgwQ9Y7tLHQLPfrrMyb1yG3FY1uTwvbHSRBDnMNBdBeQfXLsjmg6v6
YPGDeptOBntsTNutgdGQ0MzM3ed64CzksfmuaeCS8DB0E0GqITNla3hJMgaG
yrzwHuDKbLK6gAcsclCOmwLn0q5A1Nys+ElktsK34GkUeDto0e0WH4zrCH7K
ttmtmdNUcCDNKBxaAUOAcU8TXO5KjkaMWbNsisVinTv3VWrBuot1Dh4nsF3u
f/uKrO+qnEw/ES+g0NvAdIlPQF+CMQ58ChexGKkL5Fm+JYgepWKgKuYLhAEp
MsK35eQzkQ+19uQkCjv3PmvPgMMI7D1wCaf6w5xKKq1hb6tm4YMWS9ztJITh
TYSQxGtRgOClokDG/hyEmhKAmLtcofClHARTBHcdLnAGc4AVallBLnc17nhn
FWUGPH/fFDyQXAD6qgXOQSF2g8oPmQvVLLIj2JxAnCaXaWzJC8CXIVZ2YF6h
np+vd2gogI8ArwH/vapKjPwxbYEaK5AgI2DqfDEMqld5JFMFflNnsN7AyG6P
4dksUJKhM6zX4zVwyc0uu8n//xZEYFWAxv8ScbTEC3DDW6L935JOP5RKzqEH
6sIWg3Uoq9bROnpQIfl6iQNnMgArp6JhScbhPdH9yExofHW1D8oz5DvYCfA9
cF7jZmjthUs4knn+WobLFgvMeuEXcBuoJRo9mPVdvQqTkyVB/Qg7vbpjQtqN
wSLnriDFjnsNZxq5H2XX97cYS83v4Pev/BvcYUQ7GBMIgx9+5c8+ZLh+8NkW
ff57mjhOx7n/kD8xUuCv6rl/6A98Z670Hx+8EL77aK+8nD585eXUXHnk/U8P
XHeE3/0Ur708xh+PDo/J34WLadjDYx+F78LYl0/g/0/pt2d7I5vvnBn8I469
9wQY/Cf+zsz+8jn9fIGvPsEfhjj739EtTOmP6Q/58/Fj+Ck/8JbL+e0UfxzT
r4/wx+PwkAPfOXqOsorGKc0f/UoFyhHtPDRZh0KHa+WvPQIjw8Hcgu/Fe4HN
4CYy4W8n/qtlcTOqbkfIq+zUf9N7kH97n1ClopTB7aPOBWgTTjrgRslm6Ofn
3RFAZv/2m3nUp08iDtw6X7ZDkZJyE05WhEUNOgMVOW6r8wsTVXYvG/IKrMUt
hjlKHbivKNUVwh2GD7AOh8pxFCTgW4vcDNJRXDK6HVdvPB7jooH+K5N5SNbn
/F2chqs5rjpklQ96me4GprsrwNkjd6qpRmJsJLeqzIJpDX1O9h9cde/ImSnR
WMsXBfnSNHID2w6Hfjb2P4IQz9EIyDrzkzmsMrFRgMBut2XgQxgG3nm+qlBJ
oMkwRMobPw1UIOloJGyQ5PKS7vLizdCL7yyfoUbikCVcBzvrrtqtF8EDpmfS
kqCvcfmE1x43H13nHrjuGWmXukbJDpoFH8fEWlV3pZoEwkFjzwyDO8c5WLFD
dtqyk7kDUw8Wd5F/wGA6O8wWwtLHwQZD99tvko3+9GlofEEgb6YeIQ2XRb01
dMTd6EXOilbnGtWa7lJUljFM4kmlkW6RNeyfvoEpjI0S+fPl85MnQOKTF0jA
E2AxYLOT6bOf/TfOTeDPdNL9eeCPPygQMOTVFQg0mzBxlAbnZl/jHUgVWhvg
Vf/Tny+Lk1kBLPrTz75ffPNk+GI4nQyn03+AQfhf0+H02cBQQNkIubJ3WfRc
DEGwS5s1TTUveGcfIibnuXxvVvTQmBp73LHoFjhhjmGX+hgcQlGiW//xMY2M
EYixR2mXgQEBrtQa7E9YWDAI4s1iUZApvM3FvcDxmRVgZ+zQ62q8sM2Lp58+
ETcUSf5GntOg5cT+39LuTXwevylMVqUkvBFYKItqAwzxo2ZC6eVqijSUlZEm
eLfIiiEZWry5VVwG6ccxCVDm2bwG+xAva+KCGDMOZUUPTL22YOHf40nOCtrN
ITFG9iqJr1W1Hc3uKZQA8qkrKUDajW/GJ/78anR+hXGI768u3jBVSO7d5piT
d4EmdYZOH/mt8LpLNOPICWmqdU6OLS4GzzRr957WqIj2LRrNLIEyIjHMLYiI
lJjgXAC92zznMVF1qewxghner+lII78t2AJF32yOlIN7lkN8IA9AT3H4rUpo
n//7jqISpNQwCNZn+jQqDqeT0R8un8L/H6n4hN+f4b85mKAcSN+uKJpjuLb4
C71Vxm4YfrQEJgeyo/2rngzF7Nh5HQm9YDf9qKpBnBjYMeCtwM5l3wbRBG0S
1HQkx3Tl0L6GL9dF+T7QKRgJEsbMGc7Gypd4nje1k62H8UZ9OslakCkoxmIY
dUnuPVOftU8NFC1qUh0YbWjd44nxb20MbOmPnzxlbqYgrUT3aNouCGd9H/bw
8y3wRpvL7EDggG9CkZOh3WiyImSFOBsZ59gMhS9wX8HUzIQ4aNhmFKYpyv0B
cf/LopR+b4Jwx3yNowLzf8DVvt8jO8UMGnb7cF6H6NK1CTjE2JioPls3or3d
HFT1feTnebXFOBa9IoikbBPeYZvdr6tsMUQ+ytCAJD0J19+ThONlI9HMQ2aH
pjdmIY+LXcOWQWcNJAoIDdxkS/DV4K/HlkE22X1gCZBhMHH4Oiwjz5Z2aLHE
WDBbelnjdsiVo3Su8lKyarhegWl4xQ5POZooYNyTIo1ZEIpLn5ksSF+uGwxZ
kyDwTVVt1A52jy8qhzuR3O/oBqy69oWwCSsFEqF7tqbdq06ZZihCJVNHgCMr
ZDfBE3uawukFS21Iu3K7qzF01JBixGXBxR81cGNLcggumYHsAQ8cyBBEblCr
OFBqAE0vj08eg8a6fHICJuTlE7CIpk/w7xcn06cgFy8fnRzDvx9dPjt5dAxm
JNpJj17QL9OTx8c/k51kDKRpMJOm3b+mD9pJSNp9Swmdts8aS22ua0g5Y2Ak
sJg+XN4Hmym1izDjBNqU1hv3GW8LUMLzupjl0STe97WGkrPSzYeswdqZtV7H
hAMKnyFn41w61ulBmwsXlt+ifA83gRa6Z92ttrxIdIceyj1fRvsiiiBURlaM
wg59j1wCXhK5mbiXKVozX6HfhNx1Q4YU72K8hr5Oc49GegeNAdo7ZC1zZnxX
lBoy1RhyuDNjMa7rSfzedLi9ARatRWq4jFJXpP9lDwANUGaim4RZMZxrkGsU
ZmRwnqTbJOHqwMZBqKFNhg5xe1C4rqzKEdkII7IRcBP5uIlo/vKAPgoU2OSI
dQc7xOypgYggCluRBflQYkwQ+ZpRZJadS3QXKEbvzy8jLhXbkUo0TAfCncuC
uYHt6bWkKA3jxmBdYa1o4A5XbTniDLf/usO9AryILA1brbdcZ23PsCO8LSdS
JQfMHgHOczdfWQ7pIxO6JFM8GCOkM2opmhdyJ4Y1+MXDLF06S9J/CPGZ08ut
q+o9qR+KlTRWal3dA199ILjvD95/QzHN3/zJn73/7tvia/+z/+ToV/4KgWBw
wTf+soB9aWMkXFYB37H4ABOf4JWXUxwLjHj8+YR+YpBriEEu//PPQ4zhnfwZ
PGr4AaYTBb1+/hkk4VW+AdYo5jJICJEQv8cU4uUxDjF2FPVLL7pE5AYM3/kU
A3cg0WD6mpQORMRnTcHQQ18f3iRb32X3SjSyAOP30QGLQd7IMvJtv3fy5x7y
j9h/A4qVnS/RhD90myzPUO8HXp2MI50DdRuCkWgQvr/I5wiiGRBS+8sI7lOK
eyQ5Rxb3/qOoosYc7T/jT7z19sB/t15/+vSf4ScFHsfhDyZvEaNdcSwE96cN
4cULXRoWPfDz8Fdw32TqQRlPjv0Efj7xk8d+8tyDxT55gT/hz+QRffUMvwI1
Dh8CgSaKv9wb9Ise6pPXtH/e8lKDPFovmu6X4D0d3ltcU/DQIh+0DWp0IlLD
AGO4kfv0KY2YB9ZtJFmDcQIWnHgj7fpUNSXqG56Hyv7yw8lPf/7u2+kQXgfk
SPnTz85aEqBkLj/EYGjYq9a1gM9xAPhx7Hdb/mc55nxqZ2ymUBHQADgKvNII
PwaHkSyJ774l544yi+jiZb4XNmPPSFSd+d/h8DD63/30c4yhYKyQ8jPgwS3N
x8/hjV/A/yvcWrCzYAlfdimXbl/V8lYM1AdctaLh3Cb56Sf8KhrULbqWPjir
2cYjvLUlxinYBjJxozYJnStzDT29cyGvjG+Mvjk+V1ExQDQyvkAKjh3LssCa
QYAVtAiTifqDITgpzhSYVItcMlwK6xiyg8B+wTq/BfHvwAhrg6cWNXLj36O6
72pmiWHgsJfHVsntayrrZauuOr0i2Xl6dcx/PeG/YEnh5wuWnqdXjzx8fHr1
jH7iKsNPVln6FBPc+IygJnnwVmxtpUETTFwJOJi0f5QOzgicJCN0UBZ1vyXJ
MaTcGeazkGdJblzOb8NPH7JfqCNQQ4Rv/9MPB+E6xRyaFcEolVEGT1UGH9N1
8J/5dl8Mdx7amUFnCv9paRyE8u+y0zGz04N89JCAHnGo53eldHwcy2pNVMMm
3W0ogS+eUG6khPXtlN9ctKSY3RCoxTZqH3b1gDPsJC5RBlBSLT7dwbuaJwzF
ceE8Au75CpHBlDYSh6nagBxog/U+dlcm4U3f1kWjQhEIfFdF7KDAh3D3K9Ro
AWY1PFiN3wC28YIRsHjeJIBkgiWN3bBkNyMuErbpeogxgULiFkFFJQGMBfg1
8D6RijJxIfmSfKRivnJ7cX6FgYxTV1yZQJ3xJA9ZqIRjeCpqjYiQNC4R64mo
dAJGib0dWtO4BKdXRce5T71p0C7odJSiTkzU6PsyKjzRdzyrOMCKwa5gNjd5
K8gvVwQxx4EADmGb4D68JQdKKTwEdjTInd6A4scgQwXzlbuoJIGKv52cSBn0
J/dd1cbQ+KG3pnkhQ21EOAcgF9I4UM6F61tSvHUrccdIa4pSmVRIuAM+I+9w
k2fo84P2LukZiNdQNsFKnjkGJZuxv2KEHTlsvO3Ev8fVxFBojgHyUjlvbSQV
LRMYIrcCx2pVW/tcKwTX925Wg2eO0UPaTPIeixtRw7EKKRgz5xfX/0J2g2Q1
MObGa2m3Aa2NRLZx10diY8xPstvZPCdIENolDivrCMwyUQ1uX2YMK3kUVpKi
AlcCuyNIU17my4LRtxQt0GAl0SABWkvYlfay8byTyCsFJpcUSCLEkPjxiekV
zbsM6YATAzrlCw5/rLJbJCjH/R8IymfdhAdH9seS32A/U8IkKGTctq6wkI/j
yKvKGhVD/BXTV/AXsR/GeOCBRgVhRJmCwrDTml1EqRl0mcnomWdthGTF0m6c
YDR2pBiveSCejEPrnJqumxykf4j186PHYeWo1oL3fwDNYxogxtng47LaUQmZ
RruTmTSwinchwEfSjwP0pE7VnE4CyQgfpwSZQaOCMqQXgBvvFMIQkgxsq8p7
GQS9Cb2B+R1RrE55Bt96P3xGvHyzrmbZOkQDsbxgTutjBJOiYV0Is/kQZhvB
3RkIEGQKfgt4mKYI1G7PCGSL2zADzUpQUQMt7CDSORlwTYvxUDXDHrpQUmXw
9rs5261I6vW6uIFhHUqxeXB1NJdllTHngAuzA4Qw84oCARL2FGgMPIqgj2hp
wJVVtSDCF1pszKy7QRqBHAeRjeI3xjgZTxwBMlR+wMxIUM2y4t0ek3qL3L5P
JzMuwL+8sYFOBllgyhLk2ExewIqesP2EdNvdZwUQ5yaQaVgibLIPxWa3CaLE
OEGUH0aA8ZyD8n2GwpLIX2IPhLrJ9yE8uBuQXTRajBxvoJanRV4f2a1K4l2e
iK+AV8EGgJfEQhNEe7aYdG/w3TgX6yjUnT1gkQ2TfS3GE2/AYHehgi1KEgv1
vTOx/yClkY+CC9knTOfAhmLrYP5SnInlAi4bPc8JcFQAuWW0n8lnpcVRO2+4
bxbyRQnoM4YS+FFZNBTZHWdkfaheaTkFzkYXEBhrYlimoq0NE+U0l+WAbINd
LWhj3bcs6AP0hx4oDKZsuiDY6MsIy88Fl57g1qMlHcC1UgCAOtii+nOdLMKc
rtPKAE0GLQJcJIzKDgWiXmM20o7aDDnWwdgJa69YxL8AGJiWMZZB0O51jpWr
af0B1rsgmlbMHFzoADy+qbAub6bGBaKx78FN778cYLw2B9thQfOQdWFkG7z6
+cXt0w4wgSvJiJrKmepEaT6lc0Ni3BFGZrlb+/75xcCA5wxohZyB2a5YL1Ik
iaqci/N3SJQiyJfG2JY+a6mmDjkU1YUCijXjk98W1a6B6zC/DAbwYtRWI0Sw
7EENMbeRRcdunX/wF0cXZ8lKRtsJA1M1qKIGVxesxx1uSxDyuAwVgf5Rw11d
BPMNWLV/OqDFjT7gMoifDlDxEBqBE3ewsT1QFlmAoQKY8stmOHsch9ekWzDV
62jFXvJWrmnv17kmywR4EXB9FpavOFcN2B2I+lPpgwQGb2ytSFtVYf96ylaa
pWvvtyT7k80YceUWskl7VKnKILZsDebAgtbYv7t4exVYufPadKtYFGP/Hcpe
oDK+ZScyAHPkzYOPRH/cLCTJD076qnHSecxQpa4gk0rd+rDwmMe0L+DrXVnq
VlRzTwscwviXQ2Eq0jvNKmOjyxJLkoZYyen6rwbssjCf4C4BdV+K+U5KjSQE
zXNmXJBgDEVrFaajutKJVYZxT7SVySoBOwwLnmDKBBtjETrLsa+LTwtjEKjJ
BQqhLENMFYzABtnFgZE9xawlW4fkL82GpizeWcfv533GVbcGLhgE2vs8pyIs
9KyYzhk+LtIk6Pg635FLQLAYlgWlszNOZLQdBl+FXYwZFoDVBIFGopjIBqV2
LQrFwZcFmByMRmizYt2kiui33z7TO4ngBl9FV5xrwjgv7c+SarMYwvt6FP58
vfcL/cN95Js5Colj0S/fgaLglgr+I1zyLdG23wz0V7jkghFJHLj8ggftxRUx
nkRKU6OKEgWJb8I4essde7V+m4xz+VyhZYukRB673kPp+p7k678VxpEN0cW5
kougCCWW4Q62xF2O/nu1yYV+30YcIX1qKHiktFJLxJqojFmTAqB8LYVqUVom
IpvyyxKOH1J8ALe/3EWb1Rg55mJRufAflhEwjKTNmvfBAbXv4LS4WKWoFQ2z
XBwHjDGgAEoCqYpjy9bYCYoaibmENyMn0aOjiaU6Q32bYDn41Ck0RUavqs0G
e7qYqQu6juRugDKmlwSDQ/betjW2ZVu1NqgQxNa3iiC0kbzrypuSNPR3yEvr
Pi+Y4WxVJgvkSLBr7TCa/kMBBksEKwuEwakYntLdR+EQLiEjUxjchJGUHlNh
dj+IebkC2PgMpWKJMc+oX49Qxf6XQSfChRBNv8FGGGDQ9+E2UCJohYDzEmDi
xCUqC3eKfMYa9mV4koSaSpfjB/pKcOfXF4pr1CCBBnsDKo+NgtKsQ8zlKRqP
3MbPU2qMuI08WuoaqOe4PQpf+nhkPv7EtbUd27zOb2T9qG5CrZOuZU29FBLe
HAdx/TKU5Dn3MnjpSa4NJs4U0U0Y08+Ej5Zid/hS7ZXz17HgHBMkCFzSXV/n
o4hs4zAQA8ryBqHdRbPi4Ajr08cTUFci/bKbEnY/7BYhbKwmdCafwPYTvOQ6
Y+P8M7KIDZVqhmKPMF5yvwHDi1NaNQdGD1ENDUvfs/jv+F/qqIa4TRMvXlV3
GLTewNIQAdHjxv1pV8K8a97wK82EF/tiyQ3sC25yLDoumg3X1fKghFUn0P0c
VBDa4Pd25axkp94A6FCkOGOtl6QoCJcvxVAfZZvqUKyKn2NDhB3aGDIHMsNL
CXljtIiD/tJtgv1+/FyEFGGXk7Cr3XbkleY1LlMy9wQVU6CP8ENgtqvLhN+C
z46ziFomdHxg+DazHjl5JDj2qnVj9sqsBjxKCvAx5VE07QnvTJw2CjrBMFoK
0DhsJO49YxhHMzFVqvbHWMWbiJ0fcrSddxiZhjhpa5smvDk0xQZso4c9Faxy
3LLre4kuTJ9Sduv0zSWIdlvP2zeOFOXj35zTJQJC3reOB4JPDxyqb4Z7IWDV
+UHkfJwvQ62xrJOSATWy2gB9FNQDjjwcEIUaG7TScOgOTwTbswDZ+R/s9nHX
jNQO3HFUAO05FPvBKNe9rMZTvIRT0Oyruw6sIVUvJ/6PFOMd+rdUe42r9Tat
wg7PQgwNGBz0WKFhFjw9WSkf/VTdkkgN2ne83LrPCNkX5Bu/8oHBCDUjQokn
nxgcxIyNBKf4zVyEK4U9jwoRpy1uPNeZw+gS4IaBmznYN2OPL8hRWNLH0ucm
zpiLg7hci4TSdofMi5YDdQT1ChQV2GQi3DIaAqZMm5Dv70zF9TnXTalZ2OUD
MaPFIU8S8Wy6sXxgc2o6oQWcPsfVw74MlIKSUp8kMgCzwYQR1d3QDIjOJW8L
jzjLGkfDrShLaNaLqSAVnlSi4zRmHItYKU1Ld4UJ93lErUZS85eytrEPAQaL
ZDqxYiy7BReSnipTnNd51kqmP7oYTTIpuobXD0hEysleSrDjVZHfCoYgbyg1
kfggsKPUfs+0LkUdDGluceLc3ysjsSaUVhLMRzQb3i5juFDxtLHdAd2jCA7a
KG2lqad0wrP7tFEC3glDvjLtsGjn24HIlqAu5rL/mt2MiwbCTmwIehwqrSK+
LF3QXtptqBcD97zD/p5Q0vHhGJnpwa0jhOaNAjSjF6L/lmZ97vSyf/mnQbAk
Zcsfdvl//8/XHpz7yx8m/gv/fHQf4/hff73329d0VfgXXP7x8ofRRVZnm+Yj
Pmn03bdTTx8iYvIjQZ34XyX2B/hrR7dT+0f5HJ9C5OxzKAedldHoDx8//pWk
ORyw0ARGjFjwEmjJv1kU8huaVrqVHQqvwhe9br8qz/38uXS3d/lDjxSBpto1
lcb5oAgmhTUc+zMKxF7+wObUhisBUBboEnABp8a40NMVtoN7OI6pOtFgVIWc
WgWhY7kD7GEqpP3ET/2xf+Qf+yd7l9nvnvpne/9GMNpb//eeek7U67x/+cPb
twNYP/u/BCbn03/70cP/1t/dx9nHxcerj28/nn68/EjStf/oaDo5mj4fYCgM
Hun7kyP4hwL0cFLw29Vr/BlbHhFfI1ry//QEkaffrDMwQIF9D7DjbsTKIHDj
D6M39AEyI90Icng2UGzNCdcaoRwSEFOA3SSFh6jBg7mA2lCQZCiEDJysWFKl
FVwzHfp83eTU6MYtBvka88j7T1PIVMYJScUZiS8jHH1oULRUBuevT/xLNX20
XOnw5T5Cf+O1HNFdEjmzUNDAbt02W3D2XyNfKQKZgUwUWQKtgb2KMLlEtRaz
CpRJVt/DFN8OyPbg95Zn995WmJ/ps/UxkDmyGWA0/+lAmekE5x5fKTNsZl4b
7KG7HONcbFefvj07AqZkZKg8A9eNjV/+WHIXofMfuqkDZluga6kszNGntklg
TxK+xw3BjdF4BJzqBJwqbD60PzqqsBNsP2Ji3AIbxsVkq3ogT8FVES8qWS4k
o+hgoBZIKCYkNx0QLIgJh/SIsj0au7cm0hu/mieq5ppWLgmoIRiyCtgkBe6v
1GJjAhJqjmMNEfipcBiwlMt7GggtTJhyj0ySHszb9Vix98aRh/Ujfu0CO2IW
EvoNk6PtI3qEkHJkwOLNPLSje6N9sSJL+e9gI9+Bm2lDszHSit6vps/QIr6+
3yqyj4ynpVbHCegj2Ky0AWB5YJxsxqFgY61pLpXDNvQuEhFg8eH6YGWBeTuI
IgQ5P7D3EYnXI5CuJ6xJ41cW+ez7cFm3E0YasI038h1YSoEIhLED2m0xGBH5
G5F+o0fHcgGKdqr3v9rNXlMHUel5wGhHLvB4HmkZp99ESAaPjPtLttQRbZ2T
+IG8D2s1bv3ZfQe9lGGH/lqjx/J5o8g6TCE6KsTHFxgmAFBW7LBpyVnOODcV
vz7hLwnx2Ph//MZPj58lCGJTkaHTUVIO9bY/4G3Pbbw63tTHAb/m1/QjHH4A
Ov2xhiWFqDp0vI/J/BQLxQk4IvIY/aGSTX2+4hHKbXLn0+vKhUa9ZOiAsOLd
ouQJtKQYhjz/D0QG4RcC6wqdUPxiNhLD3AQ5BT5EqUtos8BxVoFUy6V4FTwA
N1+jfyJiZll8kKRhCIrZfhyWI+L4fdB4IiEHMaljnFgFK5GwuxI5S883EZZt
VktAk1o8cuNS8szuuHtB0YgZWZSOCclVShpBf6Cx1VJdSklvdm1GD381mq1T
r68BJYGPSDvEUg4tpGpwcjwhmTpzALr+IH/zRnA2BXY1wA8ouoRjiiQO9kKZ
7K4IdTZEoFg1PS+k/kEjgxBeOBxaYxyBhDo3MmD4jb/CFZNIUSd9x0YU0to5
RtaDGSdxxOmnTwSibyJMUPesNulIKyxUMWu1UoX10NTtli0urolgIR15KK1l
qziqs8YQn8zrsBGPhvlz/yI17MVO71i+h/5nrFv3cSL/m8rfn7Ou/8qx/cwD
b/m3/tRf+q3ffoEVreRXOzo+/MHFQwv7x1wyxTGcp8D6Fs+YKTjOFtp+xah9
Kd2FeTdGK5ztbdcxtMuqDn3WtJ/E7BuwvBbfTCRsBCyAqp+NXnrgFV7wFn/E
YPNnDWASiWwEs/mJY59+MzWqNkuqL6QCAMXLNxPfKZxsk0mJ/LBzKSuHUomM
SCXf3zWx2wnsrjombzDLjRCsiJUlzS7SzFiM0nPJMTiD+2HRRRKZEpRGfENb
jsFSD+1N7sYp6cxCnCJR1JzzqoL04DZ8ptGuC5IEG4VKLlr4iLdfiBBRkyJj
5AdycOtdO5CzY/BtWD36tmjim/MLaL0DvTBfpkDmTCw5Sde64gaYKzddZQrq
36LtUIRkChIQcFEiNsMckVtgB5Nkf51WIsX9lHoXpiMPv2ZaDq+wH5XaYRiG
uFLqPSenqG0Re4C2V/E+dwENnL3PTmw/ucDH2HjoV9Dl5RyMXpKzghJmUxWB
gWiqSg93Y69SNI+iLFThkIWa0VlOScCM6KCdESI4N9nREQ0VJUKd39Vgd3P6
LZhqlGnT7ln76mLEoKCHxfW+6OSgx8T878A1/wkROprGYISW/iw1NsYhrBT8
YiJk4onNOIQVi7CIGPchRyBAZhCHaPol4YwQ6kBGO0LgiAQjjPwd+1Ptlkti
UNFbBNciwNDp+ZtrcDNCn0Nzdtk1eoiDUElndqRsAVL+WtX9Od1/mX6VWfw3
GoCZ7oggAdFsrMxmCTXFobI9rsMxMIY/2EU3/DnU+PZ4n4VefN4G+ALlTP+z
sS5nuI8NAAm2cajNPxhQ+7LR/3buPTaBtLefXT/laM5TLDWt0TGsKJHPBVSm
87JpEPKDqHN3kGM4Tb3XJz1LgzXaXwq0DJvqQEkpVqMpztjFMNV4h1iX7X2O
wYVCIVYDsu8wcS77jFG13b2m4b241dTyKbB3j7bccUWtJfQq5IM5rmgquvEu
mFfdlo4h4oQK/EGFua95SWsG6g07CpNwRAE0FrWmqn818H5X/+MsHE5gX2On
Kiz4fclTx/5HbtdKj3WsCmoCvY2DWWfwE7EXuM66DblRNkbvKpcYeFt1YckC
iy2CKWRoGfQQQ3fLinWtpKrTmZAQIyy0Bo8CSZiPHWkET4Jz59pVSt0Z2gqu
4F5X8YwNgUHQnZc/NENKYpJ6D7EXnVV35lQu/bC0JEXqX5YLrS4M4xAfIbwN
+a5aOtu3MnTKCt25YKvzrO6M+xVTesN4OgquJu4osTs22L7ZsIFSxxZOh71+
/JjooFv58ofx5yU9yPrf9eR+X9I6ktbBYaN0yXQysLnB3x/Dyua/Qi5Hq+It
JUKR0XDfSlcYcsZi20WyqaQMPRW3fJaQ+ij0TTDHKLpw+cMEWAXNRrbf8Omt
NVkIE6PiKKzNjmvRusG3KBEeOnqD4xQUEGbZO6cjyMhpYlhSAE1QsUB0NMlq
5HO+2EJXY1pgOuS59EOngYG0jsOkN53c7d8+Cgy8zu7zWsQhKR0ngsWU4TEM
cct9YFEsstzqahEGgrLF5hS6ItAquzwi+fldum1FcBV8BMs7lIVrartN208s
f25De/tU2ODyW7Ds1MlhxUUlGXfKGNgijIJvE47xxn0JYrU6qBUpfHSX6TlU
aKJzZJShGMo4ZL/F4WxhI/gZu6ZVMBy7PQOek5RE0Xk5SR0F4foQeMG1Cd+C
k37L+HS4S65iCJKLMUWkhCwhkYrCWXiAeqxTwJIg6b9Teq5jxLucFk5osMsY
6Hovtq6F75klFZKpO+IlRsaEjekZxL5cSQ+OOwYEmWVCMa4GUhEjJAg2vj6U
iU2GPog3vsf4RwxjNu4tjU66jnpSN7jOovEwMQeb4K7AVqdFhO0oeEoeYVsj
ZDGtIZ41Dhk2IvevY7mNSLiQWNFW/OqbxOgPPBeHkGaU5BYpOys1ySBIO8B3
XzthWbR75B2IBWgnYBRQFqmzt41WxhbXsAfUZ8rB5tlUyBhkw8Wlmag7YyRt
NDuDJSNiR2woCeQac4YTKCYG8E8hbA3ifd5K235UiHGvdiKyXWMqNNhWU87F
Gl1bq515s1EDzB7N7hAOMZ9qlW1IV6v9IH0SbJRGVAB30I1BWIOoTaMwbLLS
dA5EU2IpLTby2yfAcI+IRsRwHmIg+TxK/TnjNJB952NjCDb9YnpVXloidWKa
z8PO9dkSC5Clk8Qsz0Phb5TXcbLWWeGOAjx1sm8cMTTzWloSqYESMqdJp8lr
81k39tJYdd4BZaXVlcHPMYa6doYbJskRk4Lc235BPpiw/uHIMAYn07Ct7ItO
5G//OvIMjF9g3Dts87rJqf4bY8baACJKrYfiEP5HMjLrrGgkQwpWdEOelWPH
4oCuQ+n8HptVhEBL1/pnBxiFjNt7j3EXkqktkRQRd+LcNPSfphDLA7MfxpAd
HxeBIWsTD0ITV6eImKWq/YwpMSuk2wR54Vl04XEU7LNsUuTSkiK+GpFSt7qp
C6wFL49jSJVEyJGZ1VFvHR5Q30cfBadEh2IySBszHzE1w3bXIgZBuU08zX7G
6VXJ04SoKJCSuq5RES/pT50KPziU6UpQkVslyfyw0pgiTnU6EZHEpi0AkVFL
9cO9LFhZqeEImZ7dRXvmWFr0yNEA2lfWTl00LLXBCVuCXxjHM0VcKLbZeaJW
I+v4Zo2AFOAXejndrW9CPaAgPAlTiuS9LRbYrURicW8RECLGra0D0IPU0ApU
QDlZllkHMRpw5aFBgxEiitDFwiJq5BQijcjY3FbNxDYdrAwfGCGmAlXoSpFg
hj1U4mEazJOxLUSDZVemL4ORi9QDGuUBcWRdo98jZ0m8encBFPu+1M7Z3OpB
UrqcTsyxvwq/TpRDgpeOVZegysN5dftUnKdpifXay7mFlpIhsQziovLfl9S5
Iw/dRAweKFDhkDZW/xlYSCBywdyJN5LfplggLRFY5FQ2j20cSzp0ooIx4gaM
IUBiYvb8qQl+4tpL+4wIHuI8NAwVp40viAG626wuTPcj4ztEoYLvjJKAUF/J
yzv/oDEikJzoycQuRBKTpKXA94M7rq4Dzo1MldgJK8w0qAmqNJQNcVglEpp0
T9c9ONuuhcXTreKJNv5ypHKTTqiqqCk0qUnuRD3nYlBuF3FHQoceE7yfDP2q
ZofFOmAXZzUC91DECEIA171BnjBnYgyjYqGagew2t85BADnBKHSmL1U/DRMM
iC2uSg7wBVl1DG9wEoEL3OaasDoH4s9sRxFsXxFCciKNMLxMCkax9SVs3Q2p
5ZZ6odEFB1elqOfUsE7dv0zmwXRrua4pT21PFf4yTUIwxh45sU9CQLhp5Xyr
iXBGgZA3zh1ZjcjBJAe+Z6gIJv84VJ6ohCm4XWOVxOJG1BJJdpOj1jdyjrAe
iYB64RXWQGg68jK4a9KY3nFp3rrg4xQ6QYyCu5qAj0THkkaq2hIcLI9wTF8K
ievp1px7pjNgFW4bzi1l8LYiY2NTWqrXWAwdtk3aatSvaiRpnUmbG15/fB6r
BHKt2ZrCroF8lDbOv9mvTzpCtklq+NRaZv/AliQJ2mDi3wQcAXy1xTyeKE86
zxnG2RXNSmnTDYoFKY/KLli5TTxcI5ymHnLAoag08ZVsKQY3Gewx9stFY5+F
wYEDxhecG2RMAGYwukAMGnPZM4ZJnwZDvcplmrQ/wjiDLn/JMqtzKmU5Uh6w
+Gbqf/tqgSuu8Uv8SAKLOwy+sXdD4TAQX30KyFE9wyEAdaO84oIqwq+1UGa3
tSurFZ0U0G9CpcAeFxhWDz07qDq3y+5W6B0oUycvsvt0QjSLL/lXkW5GpDtQ
GCN0nDEdxcpGdhWEcUyzdvZATrvA1j24HhWCJfqrFyKrKFq4ksqcx3FgVYLV
Lz0aGF2MpyuZrt+hOvfdy3+Tcw9Zc0vdRaghsu4ydak25IF3VnU68XtNvZQc
rGjXay4PIBCMN5IFEUX+2gySB6fCjtSudmBqWyR2xBDjFB4ucYKb+9murUYD
kMzL4mZXaw0paTFeHNq8b49tIkplnRplYovdxmJtPm4XMbt0rKF/Her4qVgq
nKhwJm1H5/f+FsTuIpfP9cAU1ABoC8/tKSqhl5huT7Zsw1CCNcF5iKnq4t7z
9nQmxZ8nxdqxASi/09h/z8cjukwLjkNbNe2gg4/BZ+jn3TH8Qz3WwsvFBrJ1
IdZLiUzd5IdeUWp/OfbKDiq9Y2OK99iUXYeaAzp6nfAVcUTyfjgrwvYmOI58
9h6u7Rq7vsokNd0bauqkg0UbWsjGmLocZNKp0sV67wDRU4hX/DoeZWEh9sJj
2uIlSEF2qRh6YaoZDRlXSSvU2GTzBmk/ujgbmrPfPR1oU1Isa2uDda/CVEyd
ouhOGlLGkMO+bUEo2Ts1pmfDoTEuCYs1obkW1cc3nBQS9twIQJbjx3LDMOnP
5qhfCEG8Lkfm99unR5R/ue7wwzqb5WuSrLp26j0WMJhEs8koQttvjk+nLlc5
90tctrm08FqHQmxg7ppKh7n1aEqNMaMBsvYzROIq1UBkiT+ERWTfDrvvinzH
i4mmsUYWH6DduMPX1GQ1KrM3LC84HazH3GHf0CBRCslN6aLqqj84dUe9pfZK
HrTsxzZ1tZwYT3u9rqQRKuk36ZsKC0w9tio+n52aYiPfgykAWoEtEFWWTbXe
pX2YkQlg7YfUVsHWVSdhAtOIVv1/W6iNijaIDvnCSZ97yenx7pdXA9OgNE17
QJ+sKGpE2TFx81ic3WIg5QZF1XKH3eGotW8bUOHapSx2TqNUFN0a+9Z/2MoO
NOJdmcEZDSyzJB8T0UJ4sBEhH9IVjUREdXBbFQu605ltqB0S1XdNzoWP2PvQ
c6ShaMmFehl1iGLRXWs6Nwz0aTihD/WtrontJwFqy3tzWqn2YF4VFI2NXR43
RTMSs/d+7K+EGdgZensMg1A4KzT+4Z2OfRvL4t9hbWAu4YJ3L1/ZR1pnw4dM
0Z2alko8P9/VNYtrFvANRSneBYqEmviE9uib1MVsFzKyAYpk95n3feVvZdNq
mcDuVcg12rF1EPsVUUcGGKOHPexaboosm3t+3/OEEZG8RuZ7ctxY95KxfwkG
BYWe1ibetMrFxjms3Qk7KY5PE+0lR2FqMiy/RM74Lj4r3oQrK5LySC0nJjy3
SuE9cPClbLv6zNNZECDxe+ksBCfRg+dw/Mm+JmMjFqy0yvwulnetQoMlZsUS
m6SCMzdfhUASBc204zzNoWywoQPSV5MjUYhylgRP+85QVD9Mqh24vvQxt7PQ
A1rptmboaJ1D8JEnkLMB01BTTFIlq4raCbPGbozvT0BlTq4/QKgIhI/2pmQL
Sy5NsSkOp5EXWiZ7Hhsxh1QlGB5JDijmXAvrBenTrNmWB2aHC0IxUAqs1hxm
qbTXYtjMnbI1Ua2EOZAytwUJdBeyDSyWU50SCv5iVMzaIp1yXqmqDw+NRaqc
dKpp4bEvdTeiKEH3IhhTTk10PorC9L4zgbFwoEe0BfgM4CjIGJxTLzrsZvRC
g3ihz3RE1vYbHtN4iVbVCFxCNTID4mEb4ibZJsZp57PfvtpvkSZuezwe5U7P
2LYnK5sTD7sNENGhgheE7Z5HiRP6IJJZnzTt7PpUmHjaa/ue5r/7V+dDf/Ua
j0N6O4RXBOJuQQiHGq0Bx/ziShzqLH326t1FDIfYhmYc4TcVFFwe1mqDtIP9
wmxDtAio4m5fnel3SlTUC1ppATNnTzTxLdXeyVHqob5DjonvtJ7kPD+ihAOW
xWwkY7wmDTY1G4c4pPTw6JA873QmMqURNHNu+x/LITQwVuUC3rVAH7zINrSS
GV6/Onp99eqCYlL/vQJ7+/uX74YSfOprTwvuJumlL6JQls9skZZZYx+pHLpo
EaGd9n7TkzxCXoukJa+dfo35vXV2P1p2Oj3CvsBR5YlnlxiieKUNz9QWMZtC
q/JY4KklLa+MaBg5H11bA6H1XTWtA4LesxtILToJU8RZ6PsIKet0yovAxtjJ
ERnZEpsl216jU9qY5jp3MEg+FFgRE2ItpJo9VCEZtlXCbdwIbn9zHEgn2Q4s
lMTIBJvJ3YRlV5pSNjEjXJfFVJ3GID8xE2W4qTbzL3Kws2EQSYqm6zl2V+cx
E7Urd5RpklKptHcmZg12ct5D2sA5nBJbUsgcvMi1Uy84blypy0az9HUoXt/j
XRPWjcqTJBxo2VSupdMrSCn8KivjH1iUQyrhcJPMA/1w7eOyJraYkqLuh5rM
EcKbMaPsinNQm+J2p1d77ZU3Tf0UOysj8Ds9kgnlWdpmJ6gDkZgRS5GcdCTd
y/XgY0UPg9nVvC+2YDjV4G9yywWR4ws6rVAUBxlFaQtjY7yqvnOY2YEVPbSH
G390qI2hiFxJhIfkAJ8sboJgoeEYKizQVpoZjUoh6di79ySKvoRzRkKIwPRG
7Ei54uHV5LCMQmSpLe8oIfZegSeoqTwYwh2tY+O/IDnpEOmM0nB0NACKFyeF
W/7WRAjJ6YqNm8itYo4Vk07rdoJ3luJItbU/SoSAbRSAm56aBizAWnmvGsTK
RT2+RE9UoRaxsvlDh99thn5zdGLokYuKw1p7B2HH0+ST2NHhk36wG6CcKCC5
udqFwxA8nRIXG537NxTY98c6cDhl2HSsgg9737O67Pk+UmOg8DAXj/w0h+EF
8EfsRH0jfRpBBxLN2xjSSc/vDDCte07gpRUchJdbB9NNh2ireLKg7ctGAsAE
eskEBzuxYQXmAsQFO/PzfX3EPbb5gEGHUkndGQhjRXWF4bnG2lyBo1DdOFq9
ZahC5QwnIyLMATNVqfF/C2mU4HcUP/R2SG+KKHDYDFNjtFdp5TqvrSqor+6Q
pEHt8a50lDdJhl/o8JpFfzBwWm5bUJzmEDByv6xImUDBM/HAOAa3UI0478nA
OPYcvaGkPLGfx95ZiEHNGBQpJ7RC1ksr6YkrrGW1lczvwSyJdtgkxyWeR+hf
6tFBpAwfHZvTLfuSoujgQuklKeSL23EQUc2PjsNRVYHwpBMC50YqumLpH6MG
WOZ3hAoPTQUkD5425RpKVbnAB+X1wpP5jC8dTdquhHQM9f2N9lVIpkeHWYF7
YaIBV86ZP3tSHNYVwFYqMHKRnD3R5hrCVOEiD7izNV7NGpEgT3E2IJpOr7L2
/Oz6zXT6hLyhXeuMbyFdVKUbSrQdOsd7/gOuKJ+FkcHOvG+K2DAtvCOorNmv
yGtoCPKBXiRiWG0YnJfqQhsX2xQfzJFw/OroSWKCnRiKlEbYGBFuuIyHLOLt
WcH3heQon8oT1Vp66E5oc41bSIBUae6JWDo91aZBgI6OgEeL8H4UI4pw14T8
zu71FBZHfmavUqGPAB9F4qNuzEtBZlDkZ4HNfuqAWuGcBydHz+I5gIQtdZwU
QDgaWi73JjtPjzSKlJv9iPjnfjFcU6TUHTIGKokfciKKVTPWKaqyp84BKJGb
EUiAnA+/6feaNgffq+4NvB7gRsbFWwEubfOaK9hS/yYNRwUe1NrXfhrzGfhF
nS1JX4XkwMVjRLHl62orJ8A5zO2RtcZqG4uMlnq2jOrhq7Oz66+prVgwQKQu
Q0JmiajjkCa29d1sWQTd5PCufPxBQVyvwEAC2RP9l2hjaZ5FzmQKzb5dakfy
4WzojWrkjLRkaoQRmC+F8XaOPGNmpKNo4jHddKCe1+MS0B++KbM2wGylfKrb
LFpN+vTtYg+w8HYHMK/aMJZ6ubGxwYi/+D7IsRHg4LoNmtBAB68hPIRzAXuP
0iYJis7ccQtARgCnh/E0yWl0iCRTqH68UPILe49BMVbxdlVCaBUbiC6KsnZp
MOwkrdJzz0KgjyCDGungWoHrvfQNrgrZPSmsktaRa5cjmjjdXRaexGGAYMJ0
nhEQg+HoK4pHS2UEiAaLjuYahYB03/OJYm8AA5mlmMNu3QmnJShRakRI2nld
UK894JfqpsRNFvyIwJ+7tsDtR6USOafPzdPIFWurrcb+jxLD63MAcd9HaLhn
MwT9aioiDYukwCTFylLHLt08D+K/A6A3cgQvmKXreO/APuFyrpMWl9ga6vbE
gri34mngsefuLEGqBjuwKE16iMAlnBenA7BQksVRtXDowHNkK6WQdIE26dvF
QBBvejNLoh4XlM7ybp2VtiAgMW0dXzYcw8EBdGqw6e2UudCFjj14sJDgeXm2
SToxvpJYf4Ial2bs4fijmD/FNCEvXk1ZHcl93Nzg8Sj0tfRSc5kefWwBSgvz
7IgJVzw9gj04oLeP6Ym9ixa55uql1xCTQEyejjVtOB0TPFpeKeVNi1hma4sm
+FlqtRroaEyvayEzBgZpfrHLTwBUJ59bl0zK9bBYRkq25EtmcPZa1qH4JGPZ
7BI1JY1nrjHBWy7WkqRqinanrTQUSyiVGanQiaWK3JXfAtwdAdrjyaNs9dFR
jFkT4w+RNdMCOgFpsZWV8YDC4MkR63lKuG53W4NjV2xigITxuSi2jtHg1mf5
AfZBUr/l4t0weLzHKfo4CBMFy99R4lbeOKKOI4Jet7267mxNRENSsXXSelbK
trteAAerXotxgaEAKhlixyS2CjdgfPBtBuH2RgxH0KypPblMfKt985KtSUG9
ZzcYD4AtjIk+zWAgZDamIrBaNkJkdoIeoX6XVBWBwUgxfmJKg1uYBvS/RisC
3IBqxl7HZ6YP5H27CoWzw6jR+diu/SOHnZ5twTVp1EKhWO5NlE0BDDiPbbMn
VVwoa1124Fxbe5htKwcsoCLBMCps6ILwWcmjyBgSLBJtitC1NwEMdeOk/N5y
5Ll5TWcbU9DzPrdi2uHBntBMli/PmBK+WYlVuubcX2oNSXtB2k/o7fY0Rxhp
7IMCCf4fThItbnq/u8rUxrZ6KHHF2CtUsAxB+Pfwijxh7Wu333HH2vtO3sGg
3Gc5rF5pig64hycyUl+jiXZTILtiN24CD1/hTkP5mGbAYVOdvqZTiucKViXr
lTdbR9Q0xvWgQiQ+1iPBcrEP4rc7cwbXFbzzjf9TkWEI6193sNfxl38D8uM3
Q/8Ov77cFUP/I3z2p135a8GeFfzzxr9a7fCvn377FQdocKyfPs5QsnzY/fTx
Pivxo58+wrRv6l3x08e7DLM5MMQx/X4zp/t/+vTP8PddXozBF0e4EybGXv3x
3fFrmjAmTfw7jJggW7znWBXOE+fbl6eZEbg4PQfBWNG5ukSLypT6M1AhnsRH
kUu4hlM2H3Y2XYP0f0UAGzAVSFyOJpPOUdEYCkoau23y+ka1zW+/oc+LWU1k
h9OrIDPByxaxfgoXqPwKl0uojZPHLj0TPQjaeA4YedacB9AHcAEL+P/IwXsF
80mTBTzE9pTg5plLbt+7A8fDoTptXhtpdJdvZtXiPrqhaDZRH5T03Ik0mkgB
UBxUaCBl81Lwiw6TnDFPmBZjCfNYqFBCnkhrW8ObeWKW0Dg7U9mbVJHZOp9q
eej0jMa0o0I4C9WDSYNPNXZm2lwiPQ3mQJKMIaDSO5nJRd1+4WpswRFAU8Br
rCyHjms8tfiDVpsLvOQTXL8Yf7mg+Mv3S5STFH+hDOJGGUqOLMNKrwTiQ9a+
qGsbf0gfTqYZno8QRWPwYzHEglvAcBblRq7DpbGgmC7cZ6QzU3zCle+EjaMe
Jmx060EUlC0Zy67EIh15j8n0k3MvqQgIKSifDj9HHxIAtJGpGjCB85oDo6jT
WnAFJTlLe3LPGTfkM7YsKm3SPdoVYhSDq/ukuCYVSGlBBK/E4oS7TIulo5dP
I2p0JWtcsypM+zDyZYGTETpGtfQVn64q/YKqinuaGmcUntcpsHb8ZmKqMB7C
NlOL9D1QmW3vjZ4wFRZFUjkmlVTo6igS7jnYt/Aw4d52PnH8wKTTLqZ/MRrL
OoE7Lt7i7uRK9RJD6gTj7o7vEqloGaIvzNC02U0+kMMZkTULQclF4UyrF8OZ
jWgo4PGL6hVlx+uCbfKZAgzw0ZkyP0vnQ3G9gAkIez7GBLoumbNROL0iCLD7
gxG20M2GW1hw1LZy8WlZDWZJjWYgLJyIVNUbJpW9393HLqxjdu+cxBhKsziw
y10UeJ8kyXCcmaCWJBgnzptJ6cYoV5FU0ZEOK7gLaicpk4a6EB1RSCwr5zRM
GIU3h3XPciuLtMRwUSxUZxoUqE2GS2oOga3gYnSOnqOIC4L6iURpTxqGb4X6
FEq6GoCtpu1DQawOKXdoIXtyOrUUK8npJvhOzMEt9YJaOFQDiLVOHaNwZHT/
8gc9RyBUfiQ9evbQptEaYSrHhlEJtrTNb6RP2YHqjgC5iph74/RzARI5TNjb
WYgTEPfpY6rkrYIXzfUTjN7eLz2S7E/J2Pz5emea82kFhxo7Cq51a+yZgHKa
ihF4kg8jdSWoICmmGK2b7Yo1inpnOoPQ15IX4ar26M+PJIxEZ+Ha8fXEHc7X
IchI8y73MTmF5fBrOZE3mSuqCjwrDfsWoEF9dquFFQxB1QCsxmiBnMBRuENv
i/yO9gpYN3T4AyJI3yMQQCDG2tYHIVuavcONhdyIsHoW7gGzrH5RyMX2GWg+
CPxHMXjOoWI3MhDImEMITgSdwgxbm9OlUUx3DCzWYJ3P8GwNhMbBoy7OqMv6
jZxAK5Ge3sXj0Sl5bOeH7wyo4zeXl3zqJKWqJdkFkwWpja/5TpOnvSF4FODD
tavjyerTpyEbZ9LYJk4elViYS9Z2zGGOqO7hKPWoY+u+OwE54QiwJTcbDQcl
cAoR6kOf2fOagCzYcbMmNzq8gb+gYz1FDp6FYWg6MX7ikN4Xj837Plqi4/hG
VHiOUEVNylIEppalNfR3vW9hNBgxH7HjfBbuIqX1O8Q2aHRcYjuZKTuArmcK
gnVR4/1w11ui9XcCdrKvw87oV155D7cErSZ6yryDJIs/9MeT42mKQJwVoIDn
N5tj9GtBEcF8DAJI/CyyhBNvLaDWnQlVcRQwQPtiL3Ub3cCCi109zzsNHFmb
YQUuBXpClj+xqQgbJpOLYFfWACOLkCaEatPp8XjAe3PJaS/xBCtKxKdIAz41
IDkMdBVqxdNuxdL2oHJJ4zKeT0Ao0ZQiNAdMQkLmNHaPSR/B/SMbF5UoE9bA
NlTM7e3DpUMtIhxyv4gQsOKKyIw6bLfUHRtVeCd6NAzqlV9D+iHgrQYSFyNq
uIi6+NL0LDYZS87tsAeUxuNJORyXZM/iWiUHFGgq1cRvN4Jib3YzRprkq0JL
pDWqz1cF7ycxjcbu9D60eBEsjFIoC8eo9WMLZDK+BpZaEsfR9aPSqfpmJweV
hS7aEsZkgJatKxn703sbPeU5diE0kQ+UCcDmDD1OFY+ixQthtcUQsYdZxBVR
D1fwdaHQRatD3boCn0hPwFZYkLVaT68SUztEGDONL1Z1cVOU0jONu6W8omK6
2v2xRnfvHQy7yWhLRUXl+yjHBsyJghnG4w8Vl63iGulOtvYdWSnyTIJCbTZg
b/2FNUk3gPgS3qFcYLt04JARGA+YTmGMXEdLE3RlBP+pQERFjTQb2lxRRtbO
CFRFtn9HmKv2ReUDzKkHs7wbD8pWiTn0BAT3sf8uK39F6vaeovHKsC7RCP61
wdy8qkrxt/GkP+qBiYFdPg9oLV5UaHuI1ppkKJbYjgrBU0wl/lL1Cy6wRcAJ
BpFYi62fa53o5zQMaryHKsfALQrp13s2OakmF7S4PXF6hvYvod9jiRjB/DEk
fXpl1C0YMnQfGWLMiiUmdM1id/un0/l8BWP4AuiMZEjIHCdILttWgxp7MyyI
0myUUDS3Ecixbiic5m5qMEMbPtCbKxhg6iQZwvzNiTilfFDI0U2mrp16OWnH
XducRVv8OdG4CNqgGs84E8mna5T0Cm49l/qkvDbnh/WvzgcCslVkPVlLwK0c
YBSjT0uGFPiG2xgR17HVVKgrDbXUNLdAPcHKyQRdmDNlo06vOt5sSB8xyEp7
EOUfVkA2yqgzzgljUREnGTnHEWjwC+CaBBhGeHZgsMIUMoq1um0NV7Mi7hgR
UXRzN8NiI63NqWvh+xz8DiDfgOQa2S4bRRqH84RYTlBEVsPp7Cdq5a5iuntL
eMcebc0o5/tsxmCVISUKKpoKNo5KNreFF3WaCwyGe0TU4+K0dgVIlEAXOewC
ezTXPsZsDEtbOCoswmZumsbHe0TFIF0wIym9qEZg/+0KgjjGrRFFQ9SHsbsn
PCjopZFP2slTmG/kiqSNL8we02/IN5YiAWzL0S0u9ye2KysQvYcPYx1ajEFa
Yeb2GzvFE3ckGKIxNKaQRh3VPVdSJ+l1EnAcWB46U1Bh2rs01Dfcn19c/0ta
dSQI4lBucZc1/hBAWdO+JmkVsbwG3Meyyt4dPOnk8vH13qMRnEPxfZNypq4h
WgcS5RzKlSYUBglel6LFinuMekIEgeIbgp2FombXdPPkeDZiV5FR9g/djWWF
1ceyCTkKYM9aeFgFwu2IysbbOXkTOmp0QuISyhhyKIyLL7pvwrV1FszYTRbP
8vtKrODuE7gNiYJNMLfDDE35bh3GtKHGXnCNRNNCdXkoltaoFziiCslwi8Mw
is+ZtLGsZK8LIeUEMuqq2gqOdkhi2LzYBmQO4p7vQ/MU6mVJvaB/DxlC38j7
uIAHAXdilE5PoVYYuB6mnkgWDmgIpfb46PjMRuSTBAftWXMrPax1pGNosWPs
fIO6cpR6zo2tmzq/GDoqgnr2Yoo1BlUtZzLQh0+fPHksGWeuMH2G/xa4i9TS
i3llVg4blJHvIGEfoSNYN3PhldCZ1xy4h8FiucnxHaGExjS5QXIqjK02qbCG
gpHA93jIHcwXjOp2xahTacgqDpqQyoVTUtJWU7GoLCk2aO6BNzaST4o4Knhl
jCmNbjIStOdH3w+dmDkdTMsiazNcTNKf5n3upA6CA44LiapiwiB2F4B9IQ86
Mg8i5GpLzSrFgwb9gKdy1OW+b9IQyTVqO4zls4wbFAB7bFcJTy4WmbVOgn5O
4mzJsTAHejFwsA05aiSBBI5HUTUVkQlnXZhIVFAQlNHg1h58RDsnk8Phuvne
c5wquLj79EA9Zldsk8H6Ee2AYJiRNPrA/T+D/jdlqrYlgWtTnyUBeQTaNCrh
zCji8jIA46H6USzxC7lylGR7Qp5jjlQ3JY2TRB3cFdLClkaWL4fC77jSmDmD
GXBhIaN4Qvsiukeb/MmKx7NWVOSRGbAFXabUCmfl0FUxGteJ2NneUZXvG9Ey
tHJloNGCwGtoUCTII7CfaYrbmCGmBgHhMBk5aUYCa9L7mJMNbm89HqIi+Qfh
XBtOmTe+3+MHGD6WqEGPmzKga7XCagh9Ylf+BpSNOQ8n4onKecHHdVGOE+RN
jhY3LRcdeHOg3ZRKs3HH8jAsSSxG+TtL2BnVT2nESLSIKB2jkR60Z1SHd/g3
9gZDs08TWWV6Srzbr5oW448si9ANRjxUQRSVfMp46PLBmVBakRj7PUSiB6Y6
5jbtTJZYt6qH6kknDHy2ExCBYqYOvPNMuIw1SjqpLhPoZhi7JG5Gic/7jswI
+LJGxYc2sRZ4tM3R8tydtEk3XU2wAxVaGlS9Yfdz0qegDf2L8Sz6UVuNMEzQ
IbBWU+M6GweBJX/AEiEOjbDdokZCTqDpoA3Y7UjUVaz8UqXULQFzRjkFoA0X
PFgoTAR0jExrTRImnQkgh4JIfyQmViz2LvRoJJu7S96Sz5ZXrN3YX2Rb5gjO
QY7d/waQDnRAVukAAA==

-->

</rfc>

