<?xml version="1.0" encoding="utf-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc version 1.6.36 (Ruby 3.1.3) -->


<!DOCTYPE rfc  [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">

]>

<?rfc comments="yes"?>

<rfc ipr="trust200902" docName="draft-eckert-pim-rts-forwarding-00" category="info" tocInclude="true" sortRefs="true" symRefs="true">
  <front>
    <title abbrev="pim-rts">Stateless Multicast Replication with Segment Routed Recursive Tree Structures (RTS)</title>

    <author initials="T." surname="Eckert" fullname="Toerless Eckert" role="editor">
      <organization>Futurewei Technologies USA</organization>
      <address>
        <postal>
          <street>2220 Central Expressway</street>
          <city>Santa Clara</city>
          <code>CA 95050</code>
          <country>USA</country>
        </postal>
        <email>tte@cs.fau.de</email>
      </address>
    </author>
    <author initials="M." surname="Menth" fullname="Michael Menth">
      <organization>University of Tuebingen</organization>
      <address>
        <postal>
          <country>Germany</country>
        </postal>
        <email>menth@uni-tuebingen.de</email>
      </address>
    </author>
    <author initials="S." surname="Lindner" fullname="Steffen Lindner">
      <organization>University of Tuebingen</organization>
      <address>
        <postal>
          <country>Germany</country>
        </postal>
        <email>steffen.lindner@uni-tuebingen.de</email>
      </address>
    </author>

    <date year="2023" month="October" day="23"/>

    
    <workgroup>PIM</workgroup>
    

    <abstract>


<?line 154?>

<t>BIER provides stateless multicast in BIER domains using bitstrings to indicate receivers.
BIER-TE extends BIER with tree engineering capabilities. 
Both suffer from scalability problems in large networks as bitsrings are of limited size
so the BIER domains need to be subdivided using set identifiers so that possibly many
packets need to be sent to reach all receivers of a multicast group within a subdomain.</t>

<t>This problem can be mitigated by encoding explicit multicast trees in packet headers with
bitstrings that have only node-local significance. A drawback of this method is that
any hop on the path needs to be encoded so that long paths consume lots of header space.</t>

<t>This document presents the idea of Segment Routed Recursive Tree Structures (RTS), a unifying
approach to use either bitstrings with local node-local significance or SIDs with 
local or domain-wide significance to encode multicast trees in packet headers.</t>


<t>RTS, like RBS is intended to expand the applicability of deployment for stateless
multicast replication beyond what BIER and BIER-TE support and expect: larger networks, less
operational complexity, and utilization of more modern forwarding planes
as those expected to be possible when BIER was designed (ca. 2010).</t>

<t>This document only specifies the forwarding plane but discusses possible architectural
options, which are primarily determined through the future definition/mapping to encapsulation
headers and controller-plane functions.</t>



    </abstract>



  </front>

  <middle>


<?line 192?>

<section anchor="introduction"><name>Introduction</name>

<t>This draft expands on prior experimental work called "Recursive BitString Structure" (RBS)
for stateless multicast replication with source routed data structures in the
header of multicast data packets. Its changes and enhancements over RBS are a result from further
scalability analysis and further matching against different use cases. Its proposed design
also includes Proof of Concept work on Tofino programmable forwarding plane via P4.</t>

<t>Compared to RBS, RTS includes encoding options using either a per-hop bitstring or
a per-hop list of segment identifiers (SID) to address next hops in the multicast tree.</t>

<t>RTS, like RBS is intended to expand the applicability of deployment for stateless
multicast replication beyond what BIER and BIER-TE support and expect: larger networks, less
operational setup complexity, and utilization of more flexible programmable forwarding planes
as those expected to be possible when BIER was designed (ca. 2010). Unlike RBS, RTS does not
limit itself to a design that is only based on the use of bitstrings but instead offers
both bitstring and SID based addressing inside the recursive tree structure to support
to allow more scalability for a wider range of use cases.</t>

</section>
<section anchor="overview"><name>Overview</name>

<section anchor="from-bier-to-rts"><name>From BIER to RTS</name>

<section anchor="example-topology-and-tree"><name>Example topology and tree</name>

<figure title="Example topology and tree" anchor="fig-ov-topo"><artwork><![CDATA[
          Src                         Src
           |                           ||
           R1                          R1
          /  \                       //  \\
         R2   R3                     R2   R3
        /  \ /  \                  //  \ /  \\
       R5  R6    R7                R5  R6    R7
      /  \ | \  /  \             // \\ | \ //  \\
    R8    R9  R10  R11          R8    R9  R10  R11
    |     |    |    |           ||    ||   ||   ||
   Rcv1 Rcv2  Rcv3 Rcv4        Rcv1 Rcv2  Rcv3 Rcv4

    Example Network            Example BIER-TE / RTS Tree,
      Topology               // and || indicate tree segments
]]></artwork></figure>

<t>The following explanations use above example topology in <xref target="fig-ov-topo"/> on the
left, and example tree on the right.</t>

</section>
<section anchor="ip-multicast"><name>IP Multicast</name>

<t>Assume a multicast packet is originated by Src and needs to be replicated and
forwarded to be received by Rcv1...Rcv4. In IP Multicast with PIM multicast
routing, router R1...R11 will have so-called PIM multicast tree state, especially
the intermediate routers R2...R7. Whenever an IP Multicast router has multiple
upstream routers to choose from, then the path election is based on routing
RPF, so the routing protocol on R9 would need to route Src via R5, and R10 would
need to route Src via R7 to arrive at the tree shown in the example.</t>

</section>
<section anchor="bier"><name>BIER</name>

<t>In stateless multicast forwarding with Bit Index Explicit Replication (BIER),
<xref target="RFC8279"/>, a packet has a header with a bitstring,
and each bit in the bitstring indicates one receiver side BIER router (BFER).</t>

<figure title="Example BIER bitstring" anchor="fig-ov-bier"><artwork><![CDATA[
[R8:5 R9:9 R10:11 R11:17] =

00001000001000001000000000000000000000000 
]]></artwork></figure>

<t>In <xref target="fig-ov-bier"/>, the term [Ri:bi...] (i=5,9,10,11; bi=5,9,11,17) indicates the routers "Ri"
that have their associated bit in the bitstring number "bi" set.  In this
example, the bitstring is assumed to be 42 bit long. The actual
length of bitstring supported depends on the header, such as <xref target="RFC8296"/>
and implementation. The assignment of routers to bits in this example is
random.</t>

<t>With BIER, there is no tree state in R2...R7, but the packet is forwarded
from R2 across these routers based on those "destination" bits bi and information of
the hop-by-hop IP routing protocol, e.g.: IS-IS or OSPF. The intervening
routers traversed therefore also solely depend on that routing protocols
routing table, and as in IP multicast, there is no guarantee that the
shown intermediate hops in the example picture are chosen if, as shown there
are multiple equal cost paths (e.g.: src via R10-&gt;R6-&gt;R3 and R10-&gt;R7-&gt;R3).</t>

<t>The header and hence bitstring size is a limiting factor for BIER and
any source-routing.  When the network becomes larger, not all receiver
side routers or all links in the topology can be expressed by this number
of bits. A network with 10,000 receivers for example would require at least
40 different bitstrings of 256 bits to represent all 
receiver routers with separate bits. In addition, the packet header needs
to indicate which of those 40 bitstrings is contained in the packet header.</t>

<t>When then receiver routers in close proximity in the topology are assigned
to different bitstrings, then the path to these receivers will need to
carry multiple copies of the same packet payload, because each copy is
required to carry a different bitstring. In the worst case, even as few
as 40 receivers may require still 40 separate copies, as if unicast was
used - because each of the 40 bits is represented in a different bitstring.</t>

</section>
<section anchor="bier-te"><name>BIER-TE</name>

<t>In BIER with Tree Engineering (BIER-TE), <xref target="RFC9262"/>, the bits in the bitstring do
not only indicate the receiver side routers, but also the intermediate links in the
topology, hence allowing to explicitly "engineer" the tree, for purposes such
as load-splitting or bandwidth guarantees on the tree.</t>

<figure title="Example BIER-TE bitstring" anchor="fig-ov-bierte"><artwork><![CDATA[
[R1R2:4 R2R5:10 R5R8:15 R5R9:16 R1R3:25 R3R7:32 R7R10:39 R7R11:42]

000100000100001100000000100000010000001001
]]></artwork></figure>

<t>In <xref target="fig-ov-bierte"/>, the list of [RxRy:bi...] indicates the set of
bits needed to describe the tree in <xref target="fig-ov-topo"/>, using the same
notation as in <xref target="fig-ov-bier"/>.</t>

<t>Each RxRy indicates one bit in the bitstring for the link Rx-&gt;Ry. The need to express
every link in a topology as a separate bit makes scaling even more challenging
and requiring more bitstrings to represent a network than BIER does, but
in result of this representation, BIER-TE allows to explicitly steer copies
along the engineered path, something requiredfor services that provide
traffic engineering, or when non-equal-cost load splitting is required (without
strict guarantees).</t>

</section>
<section anchor="rts"><name>RTS</name>

<t>With Recursive Tree Structure (RTS) encoding, the concept of steered forwarding
from BIER-TE is modified to actually encode the tree structure in the header as
opposed to just one single "flat" bitstring out of a large number of such bitstrings (in a
large network). For the same tree as above, the structure
in the header will logically look as follows.</t>

<figure title="Example RTS structure with SIDs" anchor="fig-ov-rts"><artwork><![CDATA[
Syntax:
  RU  = SID { :[  NHi+ ] }
  NHi = SID
  SID = Ri

Example tree with SID list on R1:
  R1 :[ R2 :[ R5 :[ R8   ,R9   ]], R3 :[R7 :[R10,  R11]]]

Semantic:
  R1 replicates to neighbors R2, R3.
  R2 replicates to R5
  R3 replicates to R7
  ...

Encoding structure:
  1 byte SID always followed by
  1 byte length of recursive structure legth (":[" in example)
    If no recursive structure follows, length is 0.

Example SID list serialization (decimal):

  R1 :[ R2 :[ R5 :[ R8   ,R9   ]], R3 :[ R7 :[R10,  R11 ]]]
   |  |  |  |  |  |  | |   | |      | |   | |   | |   | | 
   v  v  v  v  v  v  v v   v v      v v   v v   v v   v v

   ..........SIDs according to above example..........
   |     |     |     |     |        |     |     |     |
  01 16 02 06 05 04 08 00 09 00    03 06 07 04 10 00 11 00
      |     |     |    |     |        |     |     |     |
      ......................Length fields................

Tree with SID list on R2:
  R2 :[ R5 :[ R8   ,R9   ]]
]]></artwork></figure>

<t>In the example the simplified RTS tree representation in <xref target="fig-ov-rts"/>, Rx:[NH1,... NHn]
indicates that Rx needs to replicate the packet to NH1, NH2 up to NHn.
This [NH1,... NHn] list is called the SID-list.  Each NH can again be a "recursive" structure
Rx:[NH1',...NHn'], such as R5, or a leaf, such as R8, R9, Ro10, R11.</t>

<t>A simplified RTS serialization of this structure for the packet header is
also shown: Each router Ri is represented by am 8-bit SID i. The 
length of the following SID list, :[NHi,...NHn], is also encoded in one byte.
If no SID list follows, it is 00.</t>

<t>When a packet copy is made for a next-hop, only the relevant
part of the structure is kept in the header as shown for R2.</t>

<figure title="Example RTS structure with bitstrings" anchor="fig-ov-rts-bits"><artwork><![CDATA[
Example tree with bitstrings on R1:
  BS1 :[ BS2 :[ BS5 :[ BS8,  BS9  ]], BS3  :[BS7 :[BS10, BS11]]]

Example bitstring serialization (decimal):

   ....List of next-hops indicated by the BitStrings.........
   |       |    |       |     |        |      |       |     |
  R2,R3   R5   R8,R9   Rcv   Rcv      R7     R10,R11 Rcv   Rcv
   |       |    |       |     |        |      |       |     |
  06 16   02 06 05 04  01 00 01 00    02  06 06  04  01 00 11 00
      |       |     |      |     |         |      |      |     |
      ......................Length fields.......................

Example tree with bitstrings on R2:
  BS2 :[ BS5 :[ BS8,  BS9  ]]
]]></artwork></figure>

<t>Instead of enumerating for each router the list of next-hop
neigbors by their number (SID), RTS can also use a bitstring
on each router, resulting in a potentially more compact encoding.
Scalability comparison of the two encoding options is discussed later
in the document. Unlike BIER/BIER-TE bitstrings, each of these bitstring will be small,
as it only needs to indicate the direct neighbors of the router for which
the bitstring is intended.</t>

<t>In <xref target="fig-ov-rts-bits"/>, the example tree is shown with this 
bitstring encoding, also simplified over the actual RTS encoding.
BSi indicates the bitstring for Ri as an 8-bit bitstring.
On R8, R9, R10, R11 this bitstring has bit 1 set, which
is indicating that these routers should receive ("Rcv") and decapsulate
the packet.</t>


</section>
<section anchor="summary-and-benefits-of-rts"><name>Summary and Benefits of RTS</name>

<t>In BIER for large networks, even small number of receivers may
not fit into a single packet header, such as aforementioned when having 10,000
receiver routers with a bitstring size of 256. BIER always requires to
process the whole bitstring, bit-by-bit, so longer bitstrings may cause
issues in the ability of routers to process them, even if the actual length of
the bitstring would fit into processable packet header memory in the router.</t>

<t>In BIER-TE, these problems are even more pronounced because the bitstrings
now need to also carry bits for the intermediate node hops, which are
necessary whenever the path for a packet need to be explicitly predetermined
such as in traffic engineering and global network capacity optimization through
non-equal cost load-balancing, which in unicast is also a prime reason
for deployment of Segment Routing.</t>

<t>These scalability problems in BIER and BIER-TE can be reduced by intelligent
allocation of bits to bitstrings, but this requires global coordination, and
for best results good predictions of the most important required future multicast
trees.</t>

<t>In RTS, no such network wide intelligent assignment of addresses is required,
and any combination of receiver routers can be put into a single packet header
as long as the maximum size of the header is not exceeded (including of course
the intermediate nodes along the path).</t>

<t>Unlike Bier/BIER-TE, the RTS header can likely on many platforms be larger
than a BIER/BIER-TE bitstring, because the router never needs to examine every
bit in the  header, but only the (local) bitstring or list of SIDs for this router
itself and then for each copy to a neighbor, it only needs to copy the recursive structure
for that neighbor. The only significant limit for RTS in processing
is hence the maximum amount of bytes in a header that can be addressed.</t>

</section>
</section>
</section>
<section anchor="architecture"><name>Architecture</name>

<t>This version of the document does not specify an architecture for RTS.</t>

<t>The forwarding described in this document can allow different architectures,
also depending on the encapsulation chosen. The following high-level architectural
considerations and possible goals/benefits apply:</t>

<t>(A) If embedding RTS in an IP or IPv6 source-routing extension header, RTS can provide
source-routing to eliminate stateful (IP) Multicast hop-by-hop tree building protocols
such as PIM. This can be specifically attractive in use cases that previously used
end-to-end IP Multicast without a more complex P/PE architecture, such as enterprises,
industrial and other non-SP networks.</t>

<t>(B) The encoding of the RTS multicast tree in the packet header makes
it natural to think about RTS providing a multicast "Segment Routing" architecture
style service with stateless replication segments: Each recursive structure is an RTS segment.</t>

<t>This too can be a very attractive type of architecture to support, especially for networks
that already use MPLS or IPv6 Segment Routing for unicast. Nevertheless, RTS can also be beneficial
in SP networks not using unicast Segment Routing, and there are no dependencies
for networks running RTS to also support unicast SR, other than sharing architecture concepts.</t>

<t>(C) RTS naturally aligns with many goals and benefits of BIER and even more so BIER-TE,
which it could most easily supersede for better scalability and ease of operations.</t>

<t>In one possible option, the RTS header specified in this document could even replace the bitstring of the
BIER <xref target="RFC8296"/> header, keeping all other aspects of BIER/BIER-TE reusable. In such an
option, the architectural aspects of RTS would be derived and simplified from <xref target="RFC9262"/>,
similar to details described in <xref target="I-D.eckert-bier-cgm2-rbs-01"/>.</t>

</section>
<section anchor="specification"><name>Specification</name>

<section anchor="rts-encapsulation"><name>RTS Encapsulation</name>

<figure title="RTS encapsulation" anchor="fig-rts-encap"><artwork><![CDATA[
+----------+--------+------------+
| Encap    | RTS    | Next Proto |
| Header(s)| Header | Payload    |
+----------+--------+------------+
]]></artwork></figure>

<t>This document specifies the formatting and functionality of the 
"Recursive Tree Structure" (RTS) Header, which is assumed to be located in a packet
between some Encap Header and some Next Proto / Payload.</t>

<t>The RTS header contains only elements to support replication to next-hops,
not any element for forwarding to next-hop. This is left as a task for the Encap Header
so that RTS can most easily be combined with potentially multiple alternative
Encapsulation Header(s) for different type of network protocols or deployment use cases.
Common Encap Headers will also require an Encap Header specific description of the total length of the RTS Header.</t>


<t>In a minimum (theoretical) example, RTS could be used on top of Ethernet with an
ethertype of RTS+Payload, which indicates not only that an RTS Header follows, but also
the type of the Next Proto Payload.</t>

<t>See the encap discussions in <xref target="encap-discussions"/> for considerations regarding BIER
or IPv6 extension headers as Encap Headers.</t>

</section>
<section anchor="rts-addressing"><name>RTS Addressing</name>

<t>Addresses of next-hops to which RTS can replicata are called RTS Segment IDentifiers (SIDs).
This is re-using the terminology established by <xref target="RFC8402"/> to be agnostic of the addressing
of the routing underlay used for forwarding to next-hops and obtaining routing information
for those routing underlay addresses. Specifying an encapsulation for RTS requires specifying how
to map RTS SIDs to addresses of the addresses used by that (unicast) forwarding mechanism.</t>

<t>RTS SIDs are more accurately called RTS replication SIDs. They are assigned to RTS
nodes. When a packet is directed to a particular RTS SID of an RTS node it means that
that node needs then to process the RTS Header and perform replication according to it.</t>

<t>Using the SR terminology does not mean that RTS is constrained to be used
with forwarding planes for which (unicast) SR mappings exist: IPv6 and MPLS, but
it means that for other forwarding planes, mappings need to be defined.
For example, when using RTS with <xref target="RFC8296"/> encapsulation, and hence BIER addressing,
which is relying on 16-bit BFR-id addressing (especially the BFIR-id in the
<xref target="RFC8296"/> header), then RTS SIDs need to map to these BFR-ids.</t>

<t>If instead RTS is to be deployed with (only) an IPv6 extension header as the Encap Header,
then RTS SIDs need to be mapped to IPv6 SIDs.</t>

<t>This document uses three types of RTS SIDs to support three type of encoding
of next-hops in an RTS Header: Global, Local and Local bitstring RTS SIDs.</t>

<t>All SIDs map to a unicast address or unicast SID of the node which the RTS SID addresses.
This unicast address or SID is used in an Encap Header when sending an RTS
packet to that node.</t>

<t>The type of an RTS SID determines the encoding and scope of the SID. Global and Local SIDs
are used in the SID-list encoding option of the RTS header, Local bitstring SIDs are used
in the local-bitstring encoding option of the RTS header.</t>

<t>Local and local bitstring RTS SID are valid only on an individual RTS node because they are both
so compact in their encoding that only a limited number of RTS nodes can be addressed by them.
Global RTS SIDs are valid on every RTS node: Using Global RTS SIDs allow the creator of an
RTS Header to steer a packet copy from any RTS to any other RTS node. Local and
local bitstring SIDs allow to only steer traffic across adjacencies predetermined by network
and/or operator policy that allocates these SIDs, typically L2 adjcencies between RTS nodes.</t>

<t><list style="symbols">
  <t>Global RTS SIDs are 15 or 23 bit values depending on the size of the deployment.</t>
  <t>Local RTS SIDs (or abbreviated local SIDs) are 7-bit values 1...127.</t>
  <t>Local bitstring RTS SIDs (or abbreviated local bitstring SIDs) are values from 1.. (8*N).
N is the size of the local bitstring for the node on which the local bitstring SID is
allocated. The value of the local bitstring SID indicates the bit in that bitstring  that
needs to be set to indicate that a copy to the node addressed by the SID is needed.</t>
</list></t>

<t>Each RTS SID has flags associated with it that define encoding and processing of
RTS packet when the SID is processed in the RTS header by an RTS node that is
sending a packet to that SID.</t>

<t><list style="symbols">
  <t>The D)eliver Flag indicates that the node addressed by the SID needs to receive
a copy of the packet by appropriate disposing of the RTS Header and processing
of the Next Proto Payload.</t>
  <t>The B)roadcast Flag indicates that the node addressed by the SID need to broadcast
a copy of the packet to a preconfigured list of "all-leaf-neighbors".</t>
  <t>The RU Flag indicates that the RTS header contains a recursive unit for the SID.
When the node addressed by the SID receives the packet, it will act as a transit node
and create copies to the nodes in that RU.</t>
</list></t>

<t>All Flags for a SID are processed by the node that is sending a copy to the addressed SID,
but not the node which is addressed by the SID itself. That node is only the receiver of
a copy of the packet. The sending node moifies the RTS Header accordingly
for the Flags so that the addressed node when it receives the copy will have the
Flags in the RTS Header. This is done so that network or operator policy can allocate
from the limited local and local bitstring SID space only those (combination of) Flags
for a node that are deemed necessary, as opposed to costing space in the RTS header
if the Flags where all static part of the RTS Header encoding.</t>

<t>The network is expected to make SID information available to the creators of RTS headers so they can
create one or more RTS headers to achieve the desired replication tree(s) for a payload. This includes:</t>

<t><list style="symbols">
  <t>Global SID for each node and the unicast address it maps to.</t>
  <t>For each node its Local SIDs and local bitstring SIDs, its flags and the unicast address/SID it maps to.</t>
  <t>For each node its "all-leaf-neighbors" list of global SIDs (see {#all-leaf-neighbors})</t>
</list></t>

</section>
<section anchor="rts-header"><name>RTS Header</name>

<figure title="RTS Header" anchor="fig-rts-header"><artwork><![CDATA[
+--------+---------------------------------------------+ 
|        | RU0 (optional)                              |
| RTS    |+----------++--------++-------+     +-------+|
| Params ||RU0 Params|| RU-NH1 ||RU-NH2 | ....|RU-NHn ||
|        |+----------++--------++-------+     +-------+|
+--------+---------------------------------------------+
]]></artwork></figure>

<t>The RTS Header consists of the "RTS Params" field followed by an optional element
called "Recursive Unit 0" (RU0).</t>

<t>When the RTS header is processed by a router, RU0 (if present) is composed of RU0 Params as well
as 0 or more RU's, one for each next-hop.  Each of these RUs is composed like RU0 itself from
a RU Params field and potentially following RU-NHi fields.</t>

<t>RU Params differ depending on whether bitstring or SID encoding is chosen
for the packet. These differences are explained later.</t>

<figure title="RTS Params" anchor="fig-rts-params"><artwork><![CDATA[
RTS Params:
 0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+
|R|D|B|S| Rsvd  |
+-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t>The (R)U0 bit indicates whether a RU0 follows.</t>

<t>R=0: No RU0 follows. In this case, D MUST be 1, or else the packet is misformed.</t>

<t>R=1: An RU0 follows.</t>

<t>The (D)eliver bit indicates whether a copy of the packet should be delivered on this node
by disposing the RTS Param and processing the next-header.</t>

<t>D=0: Do not deliver a copy of the packet.</t>

<t>D=1: Deliver a copy of the packet by disposing of the RTS Header and processing of the next-header.</t>

<t>The (B)roadcast bit determines if copies of the packet should be send to all "all leaf neighbors".</t>

<t>B=0: Do not send copies to all "all leaf neighbors"</t>

<t>B=1: Send copies to all "all leaf neighbors"</t>

<t>Creating copies because of the presence D, B and RU is orthogonal from each other and can
happen in any combination. At least one copy needs to be indicated or else the packet is invalid.</t>

<t>The (S) bit indicates whether next-hops are encoded as a bitstring or SID-list. This flag
is irrelevant if R=0 (because there is no bitstring nor SID-list).</t>

<t>S=0: next-hops are encoded as a bitstring</t>

<t>S=1: next-hops are encoded as a SID-list.</t>

</section>
<section anchor="creating-and-receiving-copies"><name>Creating and Receiving copies</name>

<t>RTS relies on unicast forwarding procedures using the Encap Header(s) 
to receive packets and send copies of packets. Every copy of a packet created,
except for those that are for local reception by a node, is sent towards a unicast address/SID
according to the RTS SID it addresses.</t>

<t>In summary, RTS Params is responsible for distinguishing the encoding of the following
(optional) RU0 but also provides the bits used for processing by so-called "leaves" of an
RTS tree, where packets need to be delivered and/or broadcast to all "leaf" neighbors (where
they are then delivered).</t>

</section>
<section anchor="dcopy"><name>Creating copies because of RTS Header D=1</name>

<t>When D=1 is encountered in the RTS Params, an (internal) copy of the packet is created
in which the headers up to the RTS Header are disposed of according to the procedures specified
for Encap Header(s) so that the Next Proto Payload after the RTS Header is processed.</t>

</section>
<section anchor="all-leaf-neighbors"><name>Creating copies because of RTS Header B=1</name>

<t>When B=1 is set in the RTS Params, a list of uncast addresses/SIDs called the
"all leaf neighbors" is used to create a separate copy of the packet for each element
in that list.  Each RTS node MAY have such a list.</t>

<t>For each packet copy made because of B=1, RU0 is removed, D is set to 1 and B to 0.
Typically, the "all-leaf-neighbors" list is (auto-)configured with the list of
RTS L2 neighbors that are known to be leaves of the RTS domain.</t>

</section>
<section anchor="creating-copies-because-of-the-presence-of-an-ru0"><name>Creating copies because of the presence of an RU0</name>

<t>The common processing of RU0 to create copies, independent of whether SID-list 
or local bitstring list encoding of next-hops is used is as follows.</t>

<t>If R=1, then the RTS router examines the RU0 header and the following RU-NHi to determine
the copies it needs to create.</t>

<t>When packet gets replicated to a NHi (1...n) with an RU-NHi, RU0 gets replaced by RU-NHi,
all RU0 data before and after RU-NHi is skipped when rewriting the packet header for
the copy to NHi. If a packet copy gets replicated to a next-hop not including an RU-NHi,
the copy to that next-hop will not include any RU0. In this case, the Flags for the
SID of that next-hop will include the D and/or B flag, and these flags will be accordingly
set in the copy sent to the node so that it delivers and/or broadcasts the packet.</t>

<t>The following example shows how a copy made to NH2 will cause RU-NH2 to become RU0 on the
copy of the packet made for NH2:</t>

<figure title="Example copy to NH2" anchor="fig-rts-example-nh2"><artwork><![CDATA[
Original RTS Header at this hop:
+--------+---------------------------------------------+
|        | RU0                                         |
| RTS    |+--....----++--------++-------+     +-------+|
| Params ||RU0 Params|| RU-NH1 ||RU-NH2 | ....|RU-NHn ||
|        |+--....----++--------++-------+     +-------+|
|        |            |<........... RU List..........>||
+--------+---------------------------------------------+
         <--- discard -------->||<-copy>||<--discard-->|
                                  (&strip)

Copy sent to NH2:
+--------+-------------------------------------------+
|        | RU0 (was RU-NH2 on prior hop)             |
| RTS    |+--....----+--------+-------+     +-------+|
| Params ||RU0 Params| RU-NH1'|RU-NH2'| ....|RU-NHn'||
|        |+--....----+--------+-------+     +-------+|
+--------+-------------------------------------------+
]]></artwork></figure>

<section anchor="replication-with-sid-lists"><name>Replication with SID-lists</name>

<figure title="RTS Header with SID-list format (S=1)" anchor="fig-rts-slist"><artwork><![CDATA[
+--------+--------------------------------------------+
|        | RU0 (present if RTS Params RU=1)           |
| RTS    |+...........+--------+-------+     +-------+|
| Params |. RU0 Params| RU-NH1 |RU-NH2 | ....|RU-NHn ||
| (S=1)  |+...........+--------+-------+     +-------+|
+--------+--------------------------------------------+
]]></artwork></figure>

<t>This section describes replication with SID-list. The SID-list
format is indicated by S=1 in the RTS Param field of the header.</t>

<figure title="RU-NHi in SID-list format" anchor="fig-rts-ru-nhi-sid"><artwork><![CDATA[
|<--- RU-NHi RU Params ------>|<-- RU-NHi RU List --------->|
+-+-+-+ ... +-+-+-+-+-+-+-+-+-+-+....-+-+....-+     +-+....-+
|G| RU-NHi    |  RUlength     |RU-NH1'|RU-NH2'| ... |RU-NHn'|
| | SID       |  (optional)   |       |       |     |       |
+-+-+-+ ... +-+-+-+-+-+-+-+-+-+-+....-+-+....-+     +-+....-+
  |<-7/15/23->|               |<....... optional ..........>|
]]></artwork></figure>

<t>When forwarding with the SID-list RTS format, RU Params in RU-NHi
contains the SID of the router to which the RU is destined.
If the SID indicates the RU flag, then the SID is followed by
a RUlength field and a list of zero or more RU-NHi' as shown in
<xref target="fig-rts-ru-nhi-sid"/>.</t>

<t>If the G)lobal bit of RU Params is 0, SID is 
a 7-bit long local RTS SID assigned by the router
processing the RU0. If G is 1, SID is a global SID with
a deployment chosen length of 23 or 17 bit, which needs
to be common across all RTS nodes in the RTS domain.</t>

<t>Note that instead of being configurable, this length could
also become a specification defined size in later versions of this document.</t>

<t>RU0 Params in the SID-list format is empty. It is stripped
from RU-NHi when the packet copy is made so that that RU-NHi
becomes RU0 of the packet copy.</t>

<t>The reason for stripping it is because it serves no
purpose anymore. The Encap Header is responsible to deliver
the packet to the correct RTS neighbor. Once that RTS
neighbor receives the packet, it may not be able 
to interpret the SID, because that SID could be a local SID
from the context of the sending node, and some forwarding
planes like MPLS make it impossible to know who sent a packet.</t>

<t>Likewise, the RUlength field is redundant: It was only necessary
when creating the packet copy, copying RU-NHi into the new
packet copy towards NHi, based on RU-NHi's RUlength field. 
Once the new packet copy is created, it's Encap Header will
need to have it's length field updates according to the new
RU0 length, so this information does not need to be duplicated
in the RU0 itself.</t>

<section anchor="encoding-and-allocation-of-sids"><name>Encoding and Allocation of SIDs</name>

<t>D), B) and RU) flags are properties of SIDs so that they
do not unnecessarily require a fixed amount of bits in the encoding,
when it is clear for specific nodes that they do not ever need
all of the encodings. This is especially true, when local SIDs
are used, or global SIDs with 15 bit in networks close that that
amount of required SIDs.</t>

<t>When global SIDs use 23 bits instead, there should be enough
SID space to allocate all 7 possible Flag combination for
each node, maybe even by allocating the last 3 bit of the
numeric SID representation, wasting one SID number for every
node, just to have a simple addressing scheme.</t>

<figure title="Global SID allocation example" anchor="fig-rts-glob-sid"><artwork><![CDATA[
+----------+--------------+-------+---------------------+
| Type     | SID          | Flags | Encap data          |
+----------+--------------+-------+---------------------+
| Global   | <Node1 SID1> |D      | <Unicast Address 1> |
| Global   | <Node1 SID2> |  B    | <Unicast Address 1> |
| Global   | <Node1 SID3> |D B    | <Unicast Address 1> |
| Global   | <Node1 SID4> |    RU | <Unicast Address 1> |
| Global   | <Node1 SID5> |D   RU | <Unicast Address 1> |
| Global   | <Node1 SID6> |  B RU | <Unicast Address 1> |
| Global   | <Node1 SID7> |D B RU | <Unicast Address 1> |
| <unused> | <unused>     | ...   | ...                 |
| Global   | <Node2 SID1> |D      | <Unicast Address 2> |
| Global   | <Node2 SID2> |  B    | <Unicast Address 2> |
| ...      | ...          | ...   | ...                 |
+----------+--------------+-------+---------------------+
]]></artwork></figure>

<t>For optimized allocation of SIDs, the following considerations
may be used as a starting point to limit the numbrer of
local SIDs requird for nodes.</t>

<t>A large number of nodes may be leaves in the network topology.
For example, when PE routers are not in a ring, but only attached
to two P routers, they are not assumed to carry transit traffic,
and even the unicast routing protocol may accordingly be configured.
In this case this PE never needs to have the RU flag, it would
also not need a B flag, but all RTS packets arriving at it would
solely be for delivering RTS packets. Hence such
nodes only need a single SID with D flag.</t>

<t>P router attaching to such PE would need RU flag SIDs, they
may not need D flag SIDs because typically they would not
need to consume the service offered by RTS services themselves.</t>

<t>These P routers may benefit from B flag, where the list of "all-leaf-neighbors"
are all the directly connected PE routers.  In result they would
need one SID with just RU, one with B/RU and one with just B.
This third SID (B) could be avoided, in which case RTS Header
encodings would need to add a zero-filled RUlength field for this
node.</t>

<t>PE router in a ring would likely require only D, D/RU and RU
given how they have no obvious neighbors to broadcast to, and
where broadcasting would save significant encoding space.</t>

<t>In result, a common assignment scheme could use 1 SID per leaf PE,
2 per P router and 3 per ring-PE.</t>

</section>
<section anchor="receiving-and-processing-rts-packet-with-sid-list"><name>Receiving and processing RTS packet with SID-list</name>

<t>An RTS node receiving an RTS packet with SID-list format creates
copies because of D and B flags in the RTS Params field as
described in <xref target="dcopy"/> and <xref target="all-leaf-neighbors"/>.</t>

<t>If the RU flag is set and thus an RU0 is present, the node sequentially
examines the RU-NHi, determining from its global and local SID
table and the RU-NHi's SID its Flags and accordingly creates
a copy and rewrites the copies RTS Params field as described before.
The total number n of RU-NHi present is determined by the length
of the RU0 field which needs to be determined by some Encap Header
field.</t>

<t>The node determines the size of the RU-NHi from the SID and
if the SID flags indicate the RU flag from the RUlength field.
It subtracts the size of the RU-NHi from the remaining RU0 size.
If this value is less than 0, this indicates an RTS header
encoding error and processing of the packet SHOULD stop and
an error be raised.</t>

<t>If RUlength is present and larger than 0, the node rewrites 
the RU0 field of the packet so that the RU-NHi
becomes the RU0 of the packet copy - except for the RU Params
field (G/SID, RUlength), which is also stripped. If the
SID has no RU flag or RUlength is 0, then instead the packet
copy will not contain any RU0, and the RU flag in the RTS Params
is cleared for the packet copy. The node also updates the
according Encap Header field for the size of the new RTS Header.</t>

</section>
</section>
<section anchor="replication-with-local-bitstrings-rbs"><name>Replication with local bitstrings (RBS)</name>

<t>Replication with local bitstrings is an procedure in which
RU do not have a SID, but where these SID are represented
by a local bitstring in the RU0 Params. Each bit set that
local bitstring indicates a neighbors local bitstring SID to
which a copy is to be made, or a bit to indicate local
deliver or broadcast operation. This encoding is
equivalent to prior "Recursive BitString Structure" encoding,
except that it is optimized for common processing with SID-lists
and for P4 processing.</t>

<t>A local bitstring SID in the local bitstring only requires an RU-NHi if it
has the RU flag.</t>

<t>The formatting is as follows.</t>

<figure title="RTS Header with local bitstring format (S=0)" anchor="fig-rts-bitstring"><artwork><![CDATA[
+--------+-----------------------+
|        | RU0                   |
| RTS    |+---------+-+- ... -+-+|
| Params ||RU Params| RU list   ||
| (S=0)  |+---------+--- ... -+-+|
+--------+-----------------------+
]]></artwork></figure>

<figure title="RU (/RU0) with local bitstring format" anchor="fig-ru-bitstring"><artwork><![CDATA[
|<--- RU Params ----------->|<--------- RU List --------->|
|0 1 2 3 4 5 6 7|<- N*8 --->|                             |
+-+-+-+-+-+-+-+-+-+- ... -+-+-+....-+-+....-+     +-+....-+
| RUlength      | local     |RU-NH1'|RU-NH2'| ... |RU-NHn'|
|               | bitstring |       |       |     |       |
+-+-+-+-+-+-+-+-+-+- ... -+-+-+....-+-+....-+     +-+....-+
  |<-7/15/23->|             |<....... optional ..........>|
]]></artwork></figure>

<t>RUlength indicates the length of the RU without the length of RUlength itself,
which is 8 bit.</t>

<t>The length of local bitstring is configured on the node and MUST
be a multiple of 8 bits. Different nodes can have different lengths.</t>

<t>Each bit in the BitString indicates a local bitstring SID.
The considerations for those SIDs and what type SIDs
(with which flags) to allocate are like those for
local SIDs with the following changes in considerations.</t>

<section anchor="receiving-and-processing-rts-packet-with-local-bitstring"><name>Receiving and processing RTS packet with local bitstring</name>

<t>An RTS node receiving an RTS packet with SID-list format creates
copies because of D and B flags in the RTS Params field the same as
for SID-list encoding.</t>

<t>If the RU flag is set in RTS params and thus an RU0 is present, the node sequentially
examines the bits (local bitstring SIDs) of the local bitstring. If a bit
is set and the local bitstring SID it represents has the RU flag,
then RU list has an RU-NHi element for this SID, and that RU becomes the
RU0 of the packet copy sent towards that neighbor. If the SDI has no RU flag,
then no RU-NHi element for this SID is expected in SID list.</t>

<t>When creating a copy for a SID, the RTS header size is according updated
in the appropriate Encap Header field, and the RTS Param fields D/B/RU
are updated from the SID flags.</t>

</section>
</section>
</section>
</section>
<section anchor="discussion"><name>Discussion</name>

<section anchor="encoding-and-allocation-of-sids-for-delivering-and-broadcasting"><name>Encoding and allocation of SIDs for delivering and broadcasting</name>

<t>Instructing an RTS node "target" to deliver and/or broadcast
a packet can be done through a RTS node  "neighbor"
that forwards the packet to target. When SID-list encoding is used,
this is either through a global SID for target with D and/or B flag,
or a local SID from neighbor that is addressing target with D and/or B
flag. When bitstring encoding is used this is through a local bitstring
SID from neighbor that is addressing target with D and/or B flag.</t>

<t>Alternatively, deliver and/or broadcast may also happen
because of target itself evaluating a SID for itself with D and/or B
flag. When using SID-list encoding, this could happen, when neighbor
sends a packet copy to target without D or B flag in RTS Params
of the local SID or global SID. target itself could then have a 
local SID indicating itself as the destination and D and/or B flag set.</t>

<t>This option is is likely not very encoding efficient though. It would 
cost 8 bit for example to encode one out of three local SID without RU
flag on target pointing to itself as the destination and indicating D and/or B flag
(3 local SID = D, B, D/B).</t>

<t>If the packet header uses a global SID to steer the packet from neighbor
to target, then there should never be a need for this option because
there are enough global SIDs to encode all combination of flags. If a local
SID is used and this option is necessary because there are not enough
local SID to encode all desired flag combinations for target, then
the most compact encoding depends on the size of global SIDs. If it is
15 bit, then the use of a global SID would have the same encoding size.
If it is 23 bit, then this option would save one byte of encoding space.</t>

<t>When using bitstring encoding, the minimum encoding size cost of evaluating
D and/or B flags on target or on neighbor is as follows.</t>

<t>PE that are always leaves would always get only one local bitstring
SID in the bitstrings of its neighbors indicating the D bit.</t>

<t>PE that can be transit nodes, such as in rings would get one
local bitstring SID without D bit, but with RU bit in the bitstrings of their neighbors,
the PE ring node itself would have a local bitstring
SID in its own local bitstring to indicate its own delivery copy.</t>

<t>P routers adjacent to PE leaf nodes would require only
local bitstring SIDs without D bit by their neighbors. Their
own bitstring SIDs includes one SID with B bit for itself to indicate
broadcasting of packet copies to all PE leaf node neighbors.</t>

</section>
<section anchor="encap-discussions"><name>Encapsulation considerations</name>

<section anchor="comparison-with-bier-header-and-forwarding"><name>Comparison with BIER header and forwarding</name>

<t>The RTS header is equivalent to the elements of a BIER/BIER-TE header required for
BIER and BIER-TE replication.</t>

<t>(SI, SD, BSL, Entropy, Bitstring)</t>

<t>RTS currently does not specify an ECMP procedure to next-hop SIDs because it is part
of the (unicast) forwarding to next-hops, but not to RTS replication.</t>

<t>Note that this is not the same set of header fields as <xref target="RFC8296"/>, because
that header contains more and different fields for additional functionality, which RTS
would require to be in an Encap Header.</t>

<t>For the same reason, the RTS Header does also not include the <xref target="RFC8296"/> fields TC/DSCP
for QoS, OAM, Proto (for next proto identification) and BFIR-id. Note that BFIR-id is not
used by BIER forwarding either, but by BIER overlay-flow forwarding on BFIR and BFER.</t>

<t>Constraining the RTS header to only the necessary fields was chosen to make it most
easy to combine it with any desirable encapsulation header.</t>

<t>RTS could use <xref target="RFC8296"/> as an Encap Header and BIER/<xref target="RFC8296"/>
forwarding procedures, replacing only BIER bitstring replication to next-hop functionality
with RTS replication.</t>

<t>In this case, the RTS Header could take the place of the bitstring field in
the <xref target="RFC8296"/> header, using the next largest size allowed by BIER to fit the RTS header.
SI would be unused, and SD could be used to run RTS, BIER and even BIER-TE in parallel
through different values of SD, and all BIER forwarding procedures including ECMP to
next-hop SIDs could be used in conjunction with RTS replication.</t>

</section>
<section anchor="comparison-with-ipv6-extension-headers"><name>Comparison with IPv6 extension headers</name>

<t>The RTS header could be used as a payload of an an IPv6 extension header
as similarly proposed for RBS in <xref target="I-D.eckert-msr6-rbs"/>. Note that the RTS
header itself does not contain a simple length field that allows to completely
skip across it. This is done because such functionality may not be required
by all encapsulation headers / forwarding planes, or the format in which such
a length is expected (unit) may be different for different forwarding planes.
If required, such as when using the RTS header in an IPv6 extension header, then
such a total-length field would have to be added to the Encap Header.</t>

</section>
</section>
<section anchor="encoding-choices-and-complexity"><name>Encoding choices and complexity</name>

<t>Work on analysis of scalability of stateless source routing broaches a very wide
field: size and topology of network, size and distribution of receivers just to name
a few. This makes it impossible at this time to decide on a single, most simple encoding
option for structured tree source-routing encodings. Instead, RTS attempts to
combine the currently understood aspects of encoding into an as-simple-as-possible to implement
single forwarding machinery and is in process of validating this encoding with P4 Tofino.
Precursors of this work with subsets of these encoding options have already been validated
through proof-of-concept implementations.</t>

<t>The use of SID-lists in the encoding is a natural fit when the target tree is one
that does not require replication on many of the hops through which it passes, such as
when doing non-equal-cost load-splitting, such as in capacity optimization in service provider
networks. In <xref target="RFC9262"/>, Figure 2, such an example is called an "Overlay" (tree). In the
SID list, each of the SID can easily be global, making it possible for a next-hop to be anywhere
in the network. While it is possible to also use global SIDs in a bitstring, the decision to
include any global (remote) SID as a bit in a bitstring introduces additional encoding size
cost for every tree, and not only the ones that would need this bit. This is also the
main issue of using such global SIDs in BIER-TE (where they are represented as forward_routed())
adjacencies.</t>

<t>When replicating to direct neighbors, SID lists may be efficient for sparse trees. In the
RTS encoding, up to 127 direct neighbors could be encoded in 8 bit for each SID, so it is
easy to compare the encoding efficiency to that of a bitstring. A router with 32
neighbors (assume leaf neighbors for simplicity) requires 32 bits to represent all possible neighbors,
if 4 or fewer neighbors need to receive a copy, a SID-list encoding requires equal or fewer
bytes to encode.</t>

<t>Use of the broadcast option is equally possible with SID-list or bitstrings. An
initial scalability test with such an option was shown in slide 6 of <xref target="RBSatIETF115"/>, but
not included in any prior proposed encoding option; a better analys of this option is
subject to future work.</t>

<t>With all these considerations, it seems prudent to not attempt to pursue different encoding
options such as recursive SID-lists and recursive bitstrings as separate experimental
protocol proposals, because that would result in too much systematic duplication of effort
across the whole stack. One may still arrive during the course of the experiment at a conclusion
that one of the two encodings suffices.</t>

<t>The current state of understanding of implementation on P4 Tofino for the proposed encoding is
primarily that it may or may not be possible to fit the whole encoding into the available
code space, whereas bitstring and SID-list encoding alone will work. Likewise, the 8/24 bit variable
length encoding feasibility for SID-list elements also needs to be verified.</t>

<t>If not all aspects of the encoding may fully work on Tofino or leave enough room for
other forwarding code (such as unicast) to fit, this may or may not be relevant to industry
target forwarding engines. If the encoding does show being feasible and beneficial,
especially if compared to BIER/BIER-TE also on the implementation side, then RTS may 
in return be a good example of requirements that should be supportable in better next-gen
low-cost / white box switches.</t>


</section>
<section anchor="discovering-malformed-rts-headers"><name>Discovering malformed RTS Headers</name>

<t>To determine whether the encoding of an RTS Header is correct,
a node MAY add up the RUlength fields and verify that it adds
up to the size of the RU list field as determined from the
Encap Header size field for the RTS Header - before starting to
replicate the packet.</t>

<t>If a node does not do this check before creating copies for neighbors,
then malformed headers may be discovered when an RUlength field would
indicate a packet offset exceeding the RTS Header size.</t>

<t>The size of the local bitstring headers is not encoded in the RTS
Header itself, so a malformed header can most easily be a result
of the encoding node using a different size than the processing node.
This should not happen when the controller-plane mechanism to
distribute SID space information is working correctly.</t>

<t>If this issue is considered to be important enough to spend further
encoding space on, then the size of the bitstring needs to be added
to the RU Params field. For example, the high-order bit of every
byte of the bitstring could be fixed to 1 to indicate another byte
of bitstring is following and 0 to indicate that this is the last
byte of the bitstring. The correct setting of these bits is easily
validated before creating copies, and independent of bitstring size
in bytes, this only adds 12.5% overhead per SID/bit. In this case
it might be better though to only allow 16-bit multiple of local
bitstring sizes to reduce the overhead to 6.25%.</t>

</section>
<section anchor="differences-over-prior-recursive-bitstring-rbs-encodings-proposal"><name>Differences over prior Recursive BitString (RBS) encodings proposal</name>

<t>The encoding for bitstrings proposed in this draft relies again on discarding of unnecessary RU
instead of using offset pointers in the header to allow parsing only the relevant RU.</t>

<t>Discarding unnecessary RU has the benefit, that the total size of the header
can be larger than if offset pointers where used. Forwarding engines have
a maximum amount of header that they can inspect. With offset pointers, the
furthest a node has to look into the RTS header is the actual size of the
RTS header. With discarding of unnecessary RU, this maximum size for inspection can
be significantly less than the maximum RTS header size. Consider the root of tree has two neighbors
to copy to and both have equal size RU, then this root of the tree only needs to
inspect up to the beginning of the second RU (the SID or bitstring in it).</t>

</section>
</section>
<section anchor="security-considerations"><name>Security considerations</name>

<t>TBD</t>

</section>
<section anchor="acknowledgments"><name>Acknowledgments</name>

<t>The local bitstrings part of this work is based on the design published by Sheng Jiang, Xu Bing, Yan Shen, Meng Rui, Wan Junjie and Wang Chuang {jiangsheng|bing.xu|yanshen|mengrui|wanjunjie2|wangchuang}@huawei.com, see <xref target="CGM2Design"/>.  Many thanks for Bing Xu (bing.xu@huawei.com) for editorial work on the prior variation of that work <xref target="I-D.xu-msr6-rbs"/>.</t>

</section>
<section anchor="changelog"><name>Changelog</name>

<t>00 - initial version for IETF118.</t>

</section>


  </middle>

  <back>


    <references title='Normative References'>



<reference anchor="RFC6554">
  <front>
    <title>An IPv6 Routing Header for Source Routes with the Routing Protocol for Low-Power and Lossy Networks (RPL)</title>
    <author fullname="J. Hui" initials="J." surname="Hui"/>
    <author fullname="JP. Vasseur" initials="JP." surname="Vasseur"/>
    <author fullname="D. Culler" initials="D." surname="Culler"/>
    <author fullname="V. Manral" initials="V." surname="Manral"/>
    <date month="March" year="2012"/>
    <abstract>
      <t>In Low-Power and Lossy Networks (LLNs), memory constraints on routers may limit them to maintaining, at most, a few routes. In some configurations, it is necessary to use these memory-constrained routers to deliver datagrams to nodes within the LLN. The Routing Protocol for Low-Power and Lossy Networks (RPL) can be used in some deployments to store most, if not all, routes on one (e.g., the Directed Acyclic Graph (DAG) root) or a few routers and forward the IPv6 datagram using a source routing technique to avoid large routing tables on memory-constrained routers. This document specifies a new IPv6 Routing header type for delivering datagrams within a RPL routing domain. [STANDARDS-TRACK]</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="6554"/>
  <seriesInfo name="DOI" value="10.17487/RFC6554"/>
</reference>

<reference anchor="RFC8279">
  <front>
    <title>Multicast Using Bit Index Explicit Replication (BIER)</title>
    <author fullname="IJ. Wijnands" initials="IJ." role="editor" surname="Wijnands"/>
    <author fullname="E. Rosen" initials="E." role="editor" surname="Rosen"/>
    <author fullname="A. Dolganow" initials="A." surname="Dolganow"/>
    <author fullname="T. Przygienda" initials="T." surname="Przygienda"/>
    <author fullname="S. Aldrin" initials="S." surname="Aldrin"/>
    <date month="November" year="2017"/>
    <abstract>
      <t>This document specifies a new architecture for the forwarding of multicast data packets. It provides optimal forwarding of multicast packets through a "multicast domain". However, it does not require a protocol for explicitly building multicast distribution trees, nor does it require intermediate nodes to maintain any per-flow state. This architecture is known as "Bit Index Explicit Replication" (BIER). When a multicast data packet enters the domain, the ingress router determines the set of egress routers to which the packet needs to be sent. The ingress router then encapsulates the packet in a BIER header. The BIER header contains a bit string in which each bit represents exactly one egress router in the domain; to forward the packet to a given set of egress routers, the bits corresponding to those routers are set in the BIER header. The procedures for forwarding a packet based on its BIER header are specified in this document. Elimination of the per-flow state and the explicit tree-building protocols results in a considerable simplification.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="8279"/>
  <seriesInfo name="DOI" value="10.17487/RFC8279"/>
</reference>

<reference anchor="RFC8296">
  <front>
    <title>Encapsulation for Bit Index Explicit Replication (BIER) in MPLS and Non-MPLS Networks</title>
    <author fullname="IJ. Wijnands" initials="IJ." role="editor" surname="Wijnands"/>
    <author fullname="E. Rosen" initials="E." role="editor" surname="Rosen"/>
    <author fullname="A. Dolganow" initials="A." surname="Dolganow"/>
    <author fullname="J. Tantsura" initials="J." surname="Tantsura"/>
    <author fullname="S. Aldrin" initials="S." surname="Aldrin"/>
    <author fullname="I. Meilik" initials="I." surname="Meilik"/>
    <date month="January" year="2018"/>
    <abstract>
      <t>Bit Index Explicit Replication (BIER) is an architecture that provides optimal multicast forwarding through a "multicast domain", without requiring intermediate routers to maintain any per-flow state or to engage in an explicit tree-building protocol. When a multicast data packet enters the domain, the ingress router determines the set of egress routers to which the packet needs to be sent. The ingress router then encapsulates the packet in a BIER header. The BIER header contains a bit string in which each bit represents exactly one egress router in the domain; to forward the packet to a given set of egress routers, the bits corresponding to those routers are set in the BIER header. The details of the encapsulation depend on the type of network used to realize the multicast domain. This document specifies a BIER encapsulation that can be used in an MPLS network or, with slight differences, in a non-MPLS network.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="8296"/>
  <seriesInfo name="DOI" value="10.17487/RFC8296"/>
</reference>

<reference anchor="RFC9262">
  <front>
    <title>Tree Engineering for Bit Index Explicit Replication (BIER-TE)</title>
    <author fullname="T. Eckert" initials="T." role="editor" surname="Eckert"/>
    <author fullname="M. Menth" initials="M." surname="Menth"/>
    <author fullname="G. Cauchie" initials="G." surname="Cauchie"/>
    <date month="October" year="2022"/>
    <abstract>
      <t>This memo describes per-packet stateless strict and loose path steered replication and forwarding for "Bit Index Explicit Replication" (BIER) packets (RFC 8279); it is called "Tree Engineering for Bit Index Explicit Replication" (BIER-TE) and is intended to be used as the path steering mechanism for Traffic Engineering with BIER.</t>
      <t>BIER-TE introduces a new semantic for "bit positions" (BPs). These BPs indicate adjacencies of the network topology, as opposed to (non-TE) BIER in which BPs indicate "Bit-Forwarding Egress Routers" (BFERs). A BIER-TE "packets BitString" therefore indicates the edges of the (loop-free) tree across which the packets are forwarded by BIER-TE. BIER-TE can leverage BIER forwarding engines with little changes. Co-existence of BIER and BIER-TE forwarding in the same domain is possible -- for example, by using separate BIER "subdomains" (SDs). Except for the optional routed adjacencies, BIER-TE does not require a BIER routing underlay and can therefore operate without depending on a routing protocol such as the "Interior Gateway Protocol" (IGP).</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="9262"/>
  <seriesInfo name="DOI" value="10.17487/RFC9262"/>
</reference>

<reference anchor="RFC8200">
  <front>
    <title>Internet Protocol, Version 6 (IPv6) Specification</title>
    <author fullname="S. Deering" initials="S." surname="Deering"/>
    <author fullname="R. Hinden" initials="R." surname="Hinden"/>
    <date month="July" year="2017"/>
    <abstract>
      <t>This document specifies version 6 of the Internet Protocol (IPv6). It obsoletes RFC 2460.</t>
    </abstract>
  </front>
  <seriesInfo name="STD" value="86"/>
  <seriesInfo name="RFC" value="8200"/>
  <seriesInfo name="DOI" value="10.17487/RFC8200"/>
</reference>

<reference anchor="RFC8402">
  <front>
    <title>Segment Routing Architecture</title>
    <author fullname="C. Filsfils" initials="C." role="editor" surname="Filsfils"/>
    <author fullname="S. Previdi" initials="S." role="editor" surname="Previdi"/>
    <author fullname="L. Ginsberg" initials="L." surname="Ginsberg"/>
    <author fullname="B. Decraene" initials="B." surname="Decraene"/>
    <author fullname="S. Litkowski" initials="S." surname="Litkowski"/>
    <author fullname="R. Shakir" initials="R." surname="Shakir"/>
    <date month="July" year="2018"/>
    <abstract>
      <t>Segment Routing (SR) leverages the source routing paradigm. A node steers a packet through an ordered list of instructions, called "segments". A segment can represent any instruction, topological or service based. A segment can have a semantic local to an SR node or global within an SR domain. SR provides a mechanism that allows a flow to be restricted to a specific topological path, while maintaining per-flow state only at the ingress node(s) to the SR domain.</t>
      <t>SR can be directly applied to the MPLS architecture with no change to the forwarding plane. A segment is encoded as an MPLS label. An ordered list of segments is encoded as a stack of labels. The segment to process is on the top of the stack. Upon completion of a segment, the related label is popped from the stack.</t>
      <t>SR can be applied to the IPv6 architecture, with a new type of routing header. A segment is encoded as an IPv6 address. An ordered list of segments is encoded as an ordered list of IPv6 addresses in the routing header. The active segment is indicated by the Destination Address (DA) of the packet. The next active segment is indicated by a pointer in the new routing header.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="8402"/>
  <seriesInfo name="DOI" value="10.17487/RFC8402"/>
</reference>

<reference anchor="RFC8754">
  <front>
    <title>IPv6 Segment Routing Header (SRH)</title>
    <author fullname="C. Filsfils" initials="C." role="editor" surname="Filsfils"/>
    <author fullname="D. Dukes" initials="D." role="editor" surname="Dukes"/>
    <author fullname="S. Previdi" initials="S." surname="Previdi"/>
    <author fullname="J. Leddy" initials="J." surname="Leddy"/>
    <author fullname="S. Matsushima" initials="S." surname="Matsushima"/>
    <author fullname="D. Voyer" initials="D." surname="Voyer"/>
    <date month="March" year="2020"/>
    <abstract>
      <t>Segment Routing can be applied to the IPv6 data plane using a new type of Routing Extension Header called the Segment Routing Header (SRH). This document describes the SRH and how it is used by nodes that are Segment Routing (SR) capable.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="8754"/>
  <seriesInfo name="DOI" value="10.17487/RFC8754"/>
</reference>




    </references>

    <references title='Informative References'>




<reference anchor="I-D.eckert-bier-rbs">
   <front>
      <title>Recursive BitString Structure (RBS) Addresses for BIER and MSR6</title>
      <author fullname="Toerless Eckert" initials="T. T." surname="Eckert">
         <organization>Futurewei Technologies USA</organization>
      </author>
      <author fullname="Michael Menth" initials="M." surname="Menth">
         <organization>University of Tuebingen</organization>
      </author>
      <author fullname="Xuesong Geng" initials="X." surname="Geng">
         <organization>Huawei 2012 NT Lab</organization>
      </author>
      <author fullname="Xiuli Zheng" initials="X." surname="Zheng">
         <organization>Huawei 2012 NT Lab</organization>
      </author>
      <author fullname="Rui Meng" initials="R." surname="Meng">
         <organization>Huawei 2012 NT Lab</organization>
      </author>
      <author fullname="Fengkai Li" initials="F." surname="Li">
         <organization>Huawei 2012 NT Lab</organization>
      </author>
      <date day="24" month="October" year="2022"/>
      <abstract>
	 <t>   This memo introduces a compact data-structure representation of
   multicast trees called &quot;Recursive Bitstring Structure&quot; (RBS) and its
   use for (stateless) forwarding of packets that include this structure
   in their header.  It is intended as an alternative to &quot;flat&quot;
   bitstring addresses as used in BIER and BIER-TE or possible
   forwarding plane variations such as MSR6.  RBS aims to improve
   performance and scalability over flat bitstrings and simplify
   operations.

   Operations is simplified because RBS does not require the use,
   management and optimization of network-wide configured address spaces
   BIFT-ID and SI and because one common RBS mechanism can replace flat
   bitstring addresses for both shortest-path forwarding and tree
   engineered forwarding.  It intends to improve performance by allowing
   multicast to sparse set of receivers in larger networks with fewer
   packets and it intends to improve scalability by requiring less BIFT
   state on routers.

	 </t>
      </abstract>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-eckert-bier-rbs-00"/>
   
</reference>


<reference anchor="I-D.eckert-bier-cgm2-rbs-00">
   <front>
      <title>Carrier Grade Minimalist Multicast (CGM2) using Bit Index Explicit Replication (BIER) with Recursive BitString Structure (RBS) Addresses</title>
      <author fullname="Toerless Eckert" initials="T. T." surname="Eckert">
         <organization>Futurewei Technologies USA</organization>
      </author>
      <date day="25" month="October" year="2021"/>
      <abstract>
	 <t>   This memo introduces the architecture of a multicast architecture
   derived from BIER-TE, which this memo calls Carrier Grade Minimalist
   Multicast (CGM2).  It reduces limitations and complexities of BIER-TE
   by replacing the representation of the in-packet-header delivery tree
   of packets through a &quot;flat&quot; BitString of adjacencies with a
   hierarchical structure of BFR-local BitStrings called the Recursive
   BitString Structure (RBS) Address.

   Benefits of CGM2 with RBS addresses include smaller/fewer BIFT in
   BFR, less complexity for the network architect and in the CGM2
   controller (compared to a BIER-TE controller) and fewer packet copies
   to reach a larger set of BFER.

   The additional cost of forwarding with RBS addresses is a slightly
   more complex processing of the RBS address in BFR compared to a flat
   BitString and the novel per-hop rewrite of the RBS address as opposed
   to bit-reset rewrite in BIER/BIER-TE.

   CGM2 can support the traditional deployment model of BIER/BIER-TE
   with the BIER/BIER-TE domain terminating at service provider PE
   routers as BFIR/BFER, but it is also the intention of this document
   to expand CGM2 domains all the way into hosts, and therefore
   eliminating the need for an IP Multicast flow overlay, further
   reducing the complexity of Multicast services using CGM2.  Note that
   this is not fully detailed in this version of the document.

   This document does not specify an encapsulation for CGM2/RBS
   addresses.  It could use existing encapsulations such as [RFC8296],
   but also other encapsulations such as IPv6 extension headers.

	 </t>
      </abstract>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-eckert-bier-cgm2-rbs-00"/>
   
</reference>


<reference anchor="I-D.eckert-bier-cgm2-rbs-01">
   <front>
      <title>Carrier Grade Minimalist Multicast (CGM2) using Bit Index Explicit Replication (BIER) with Recursive BitString Structure (RBS) Addresses</title>
      <author fullname="Toerless Eckert" initials="T. T." surname="Eckert">
         <organization>Futurewei Technologies USA</organization>
      </author>
      <author fullname="Bing Xu" initials="B." surname="Xu">
         <organization>Huawei Technologies (2012Lab)</organization>
      </author>
      <date day="9" month="February" year="2022"/>
      <abstract>
	 <t>   This memo introduces the architecture of a multicast architecture
   derived from BIER-TE, which this memo calls Carrier Grade Minimalist
   Multicast (CGM2).  It reduces limitations and complexities of BIER-TE
   by replacing the representation of the in-packet-header delivery tree
   of packets through a &quot;flat&quot; BitString of adjacencies with a
   hierarchical structure of BFR-local BitStrings called the Recursive
   BitString Structure (RBS) Address.

   Benefits of CGM2 with RBS addresses include smaller/fewer BIFT in
   BFR, less complexity for the network architect and in the CGM2
   controller (compared to a BIER-TE controller) and fewer packet copies
   to reach a larger set of BFER.

   The additional cost of forwarding with RBS addresses is a slightly
   more complex processing of the RBS address in BFR compared to a flat
   BitString and the novel per-hop rewrite of the RBS address as opposed
   to bit-reset rewrite in BIER/BIER-TE.

   CGM2 can support the traditional deployment model of BIER/BIER-TE
   with the BIER/BIER-TE domain terminating at service provider PE
   routers as BFIR/BFER, but it is also the intention of this document
   to expand CGM2 domains all the way into hosts, and therefore
   eliminating the need for an IP Multicast flow overlay, further
   reducing the complexity of Multicast services using CGM2.  Note that
   this is not fully detailed in this version of the document.

   This document does not specify an encapsulation for CGM2/RBS
   addresses.  It could use existing encapsulations such as [RFC8296],
   but also other encapsulations such as IPv6 extension headers.

	 </t>
      </abstract>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-eckert-bier-cgm2-rbs-01"/>
   
</reference>


<reference anchor="I-D.eckert-msr6-rbs">
   <front>
      <title>Recursive Bitstring Structure (RBS) for Multicast Source Routing over IPv6 (MSR6)</title>
      <author fullname="Toerless Eckert" initials="T. T." surname="Eckert">
         <organization>Futurewei Technologies USA</organization>
      </author>
      <author fullname="Xuesong Geng" initials="X." surname="Geng">
         <organization>Huawei 2012 NT Lab</organization>
      </author>
      <author fullname="Xiuli Zheng" initials="X." surname="Zheng">
         <organization>Huawei 2012 NT Lab</organization>
      </author>
      <author fullname="Rui Meng" initials="R." surname="Meng">
         <organization>Huawei 2012 NT Lab</organization>
      </author>
      <author fullname="Fengkai Li" initials="F." surname="Li">
         <organization>Huawei 2012 NT Lab</organization>
      </author>
      <date day="24" month="October" year="2022"/>
      <abstract>
	 <t>   This document defines an encoding and corresponding packet processing
   procedures for native IPv6 multicast source routing (MSR6) using a
   so-called &quot;Recursive Bitstring&quot; (RBS) address structure.

   The RBS address structure encodes the source-routed multicast tree as
   a tree of bitstrings.  Each router on the tree only needs to examine
   and perform replication for the one bitstring destined for it.

   The MSR6/RBS IPv6 extension header encoding and processing is modeled
   after that of unicast source routing headers, RFC6554 and RFC8754,
   and shares all elements that can be shared.  To support the RBS
   structure, it is replacing the &quot;Segments Left&quot; pointer to the next
   segment with two fields to point to the next sub-tree to parse.

	 </t>
      </abstract>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-eckert-msr6-rbs-01"/>
   
</reference>


<reference anchor="I-D.xu-msr6-rbs">
   <front>
      <title>RBS(Recursive BitString Structure) for Multicast Source Routing over IPv6</title>
      <author fullname="Bing Xu" initials="B." surname="Xu">
         <organization>Huawei</organization>
      </author>
      <author fullname="Xuesong Geng" initials="X." surname="Geng">
         <organization>Huawei</organization>
      </author>
      <author fullname="Toerless Eckert" initials="T. T." surname="Eckert">
         <organization>Futurewei Technologies</organization>
      </author>
      <date day="30" month="March" year="2022"/>
      <abstract>
	 <t>   This document defines a new type of segment: End.RBS, and the
   corresponding packet processing procedures over the IPv6 data plane
   for the MSR6(Multicast Source Routing over IPv6) TE solutions.


	 </t>
      </abstract>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-xu-msr6-rbs-01"/>
   
</reference>


<reference anchor="I-D.eckert-bier-cgm2-rbs">
   <front>
      <title>Carrier Grade Minimalist Multicast (CGM2) using Bit Index Explicit Replication (BIER) with Recursive BitString Structure (RBS) Addresses</title>
      <author fullname="Toerless Eckert" initials="T. T." surname="Eckert">
         <organization>Futurewei Technologies USA</organization>
      </author>
      <author fullname="Bing Xu" initials="B." surname="Xu">
         <organization>Huawei Technologies (2012Lab)</organization>
      </author>
      <date day="9" month="February" year="2022"/>
      <abstract>
	 <t>   This memo introduces the architecture of a multicast architecture
   derived from BIER-TE, which this memo calls Carrier Grade Minimalist
   Multicast (CGM2).  It reduces limitations and complexities of BIER-TE
   by replacing the representation of the in-packet-header delivery tree
   of packets through a &quot;flat&quot; BitString of adjacencies with a
   hierarchical structure of BFR-local BitStrings called the Recursive
   BitString Structure (RBS) Address.

   Benefits of CGM2 with RBS addresses include smaller/fewer BIFT in
   BFR, less complexity for the network architect and in the CGM2
   controller (compared to a BIER-TE controller) and fewer packet copies
   to reach a larger set of BFER.

   The additional cost of forwarding with RBS addresses is a slightly
   more complex processing of the RBS address in BFR compared to a flat
   BitString and the novel per-hop rewrite of the RBS address as opposed
   to bit-reset rewrite in BIER/BIER-TE.

   CGM2 can support the traditional deployment model of BIER/BIER-TE
   with the BIER/BIER-TE domain terminating at service provider PE
   routers as BFIR/BFER, but it is also the intention of this document
   to expand CGM2 domains all the way into hosts, and therefore
   eliminating the need for an IP Multicast flow overlay, further
   reducing the complexity of Multicast services using CGM2.  Note that
   this is not fully detailed in this version of the document.

   This document does not specify an encapsulation for CGM2/RBS
   addresses.  It could use existing encapsulations such as [RFC8296],
   but also other encapsulations such as IPv6 extension headers.

	 </t>
      </abstract>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-eckert-bier-cgm2-rbs-01"/>
   
</reference>

<reference anchor="RFC791">
  <front>
    <title>Internet Protocol</title>
    <author fullname="J. Postel" initials="J." surname="Postel"/>
    <date month="September" year="1981"/>
  </front>
  <seriesInfo name="STD" value="5"/>
  <seriesInfo name="RFC" value="791"/>
  <seriesInfo name="DOI" value="10.17487/RFC0791"/>
</reference>


<reference anchor="Menth23" >
  <front>
    <title>Efficiency of BIER Multicast in Large Networks</title>
    <author initials="D." surname="Merling" fullname="D. Merling">
      <organization></organization>
    </author>
    <author initials="T." surname="Stber" fullname="Thomas Stber">
      <organization></organization>
    </author>
    <author initials="M." surname="Menth" fullname="M. Menth">
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
  <seriesInfo name="IEEE" value="accepted for &quot;IEEE Transactions on Network and Service Managment&quot;"/>
  <seriesInfo name="preprint" value="&lt;https://atlas.cs.uni-tuebingen.de/~menth/papers/Menth21-Sub-5.pdf&gt;"/>
<annotation>preprint</annotation></reference>
<reference anchor="Menth23f" >
  <front>
    <title>Learning Multicast Patterns for Efficient BIER Forwarding with P4</title>
    <author initials="S." surname="Lindner" fullname="S. Lindner">
      <organization></organization>
    </author>
    <author initials="D." surname="Merling" fullname="D. Merling">
      <organization></organization>
    </author>
    <author initials="M." surname="Menth" fullname="M. Menth">
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
  <seriesInfo name="IEEE" value="in &quot;IEEE Transactions on Network and Service Managment&quot;, vol. 20, no. 2, June 2023"/>
  <seriesInfo name="preprint" value="https://atlas.cs.uni-tuebingen.de/~menth/papers/Menth22-Sub-2.pdf"/>
</reference>
<reference anchor="Menth21" >
  <front>
    <title>Hardware-based Evaluation of Scalable and Resilient Multicast with BIER in P4</title>
    <author initials="D." surname="Merling" fullname="D. Merling">
      <organization></organization>
    </author>
    <author initials="S." surname="Lindner" fullname="S. Lindner">
      <organization></organization>
    </author>
    <author initials="M." surname="Menth" fullname="M. Menth">
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
  <seriesInfo name="IEEE" value="in &quot;IEEE Access&quot;, &lt;https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=6287639&gt;, vol. 9, p. 34500 - 34514, March 2021, &lt;https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9361548&gt;"/>
</reference>
<reference anchor="Menth20h" >
  <front>
    <title>P4-Based Implementation of BIER and BIER-FRR for Scalable and Resilient Multicast</title>
    <author initials="D." surname="Merling" fullname="D. Merling">
      <organization></organization>
    </author>
    <author initials="S." surname="Lindner" fullname="S. Lindner">
      <organization></organization>
    </author>
    <author initials="M." surname="Menth" fullname="M. Menth">
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
  <seriesInfo name="IEEE" value="in &quot;Journal of Network and Computer Applications&quot; (JNCA), vol. 196, Nov. 2020"/>
  <seriesInfo name="preprint" value="https://atlas.informatik.uni-tuebingen.de/~menth/papers/Menth20h.pdf"/>
  <seriesInfo name="DOI" value="10.1016/j.jnca.2020.102764"/>
</reference>
<reference anchor="CGM2Design" target="&lt;https://github.com/BingXu1112/CGMM/blob/main/Novel%20Multicast%20Protocol%20Proposal%20Introduction.pptx&gt;">
  <front>
    <title>Novel Multicast Protocol Proposal Introduction</title>
    <author initials="S." surname="Jiang" fullname="Sheng Jiang">
      <organization></organization>
    </author>
    <author initials="B. (Robin)" surname="Xu" fullname="Bing (Robin) Xu">
      <organization></organization>
    </author>
    <author initials="Y." surname="Shen" fullname="Yan Shen">
      <organization></organization>
    </author>
    <author initials="M." surname="Rui" fullname="Meng Rui">
      <organization></organization>
    </author>
    <author initials="W." surname="Junjie" fullname="Wan Junjie">
      <organization></organization>
    </author>
    <author initials="W." surname="Chuang" fullname="Wang Chuang">
      <organization></organization>
    </author>
    <date year="2021" month="October" day="10"/>
  </front>
</reference>
<reference anchor="CGM2report" target="&lt;https://raw.githubusercontent.com/network2030/publications/main/CENI_Carrier_Grade_Minimalist_Multicast_Networking_Test_Report.pdf&gt;">
  <front>
    <title>Carrier Grade Minimalist Multicast CENI Networking Test Report</title>
    <author >
      <organization></organization>
    </author>
    <date year="2022" month="August" day="01"/>
  </front>
</reference>
<reference anchor="RBSatIETF115" target="&lt;https://datatracker.ietf.org/meeting/115/materials/slides-115-bier-recursive-bitstring-structure-rbs-beyond-bierbier-te-00&gt;">
  <front>
    <title>RBS (Recursive BitString Structure) to improve scalability beyond BIER/BIER-TE, IETF115</title>
    <author initials="T." surname="Eckert" fullname="Toerless Eckert">
      <organization></organization>
    </author>
    <author initials="M." surname="Menth" fullname="Michael Menth">
      <organization></organization>
    </author>
    <author initials="X." surname="Gend" fullname="Xuesong Gend">
      <organization></organization>
    </author>
    <author initials="X." surname="Zhen" fullname="Xiuli Zhen">
      <organization></organization>
    </author>
    <author initials="R." surname="Meng" fullname="Rui Meng">
      <organization></organization>
    </author>
    <author initials="F." surname="Li" fullname="Fengkai Li">
      <organization></organization>
    </author>
    <date year="2022" month="November"/>
  </front>
</reference>


    </references>


<?line 1158?>

<section anchor="evolution-to-rts"><name>Evolution to RTS</name>

<t>The following history review of RBS explains key aspects of the road towards RTS and
how prior document work is included (or not) in this RTS work.</t>

<section anchor="research-work-on-bier"><name>Research work on BIER</name>

<t>Initial experience implementation with implementation of BIER in PE was
gained through "P4-Based Implementation of BIER and BIER-FRR for Scalable and Resilient Multicast", <xref target="Menth20h"/>,
from which experience was gained that processing of large BIER bitstring requires significantly
complex programming for efficient forwarding, as described in "Learning Multicast Patterns for Efficient BIER Forwarding
ith P4", <xref target="Menth23f"/>. Further evalutions where researched through 
"Hardware-based Evaluation of Scalable and Resilient Multicast with BIER in P4", <xref target="Menth21"/> and
"Efficiency of BIER Multicast in Large Networks", <xref target="Menth23"/>.</t>

</section>
<section anchor="initial-rbs-from-cgm2"><name>Initial RBS from CGM2</name>

<t>The initial, 2021 <xref target="I-D.eckert-bier-cgm2-rbs-00"/> introduces the concept of Recursive Bitstring
Forwarding (RBS) in which a single bitstring in a source routing header for stateless multicast
replication as introduced by BIER and re-used by BIER-TE is replaced by a recursive structure
representing each node of a multicast tree and in each node the list of neighbors to which to
replicate to is represented by a bitstring.</t>

<t>Routers processing this recursive structure do not need to process the whole structure, instead,
they only need to examine their own local bitstring, and replicate copies to each of the neighbors
for which a bit is set in the bitstring for this node. For each copy the recursive structure
is rewritten so that only the remaining subtree behind the neighbor remains in the packet header.
By only having to examine a "local" (and hence short) bitstring, RBS processing can arguably be
simpler than that of BIER/BIER-TE. By discarding the parts of the tree structure not needed
anymore, there is also no need to change bits in the bitstring as done in BIER/BIER-TE to avoid
loops.</t>

<t>This initial version of RBS encoding is based on a design originally called "Carrier
Grade Minimalist Multicast" (CGM2), and which started as a research project whose design is
summarized in <xref target="CGM2Design"/>. A vendor high-speed router implementation proof-of-concept was
done, as well as a wide-area proof-of-concept research network deployment, which was
documented for the 2022 Nanjing "6th future Network Development Conference". An english translation
of the report can be found at <xref target="CGM2report"/>.</t>

</section>
<section anchor="rbs-scalability-compared-to-bier"><name>RBS scalability compared to BIER</name>

<t>The 2022 <xref target="I-D.eckert-bier-cgm2-rbs-01"/> version of the document adds topology and testing
information about a simulation comparing RBS with BIER performance in a dense, high-speed network topology.
It is showing that the number of replications required to reach an increasing number of receivers does
grow slower with RBS than with BIER, because in BIER, it is necessary to send another packet copy from the
source whenever receivers in a different Set Identifier Bitstring (SI) are required, whereas
RBS requires to only create multiple copies of a packet at the source to reach more receivers
whenever the RBS packet header size for one packet is exhausted. The results of this simulation
are shown in slide 6 of <xref target="RBSatIETF115"/>.</t>

<t>While RBS with its explicit description of the whole multicast tree structure seems immediately
like (only) a replacement for BIER-TE, which does the same, but encodes it in a "flat"BIER
bitstring (and incurring more severe scalability limitations because of this), this simulation
shows that the RBS aproach may also compete with BIER itself, even though this may initially
look counter-intuitive because information not needed in the BIER encoding - intermediate hops -
is encoded in RBS.</t>

<t>The scalability analysis also assumes one novel encoding optimization, indicating replication to
all leaf neighbors on a node. This allow to even further compact the RBS encoding for dense trees,
such as in aplications like IPTV. Note that this optimization was not included in any of the
RBS proposal specifications, but it is included in this RTS specification.This optimization leads
to the actual reduction in packet copies sent for denser trees in the simulation results.</t>

</section>
<section anchor="discarding-versus-offset-pointers"><name>Discarding versus offset pointers</name>

<t><xref target="I-D.eckert-bier-rbs"/> re-focusses the work of the prior <xref target="I-D.eckert-bier-cgm2-rbs"/> to focus
only on the forwarding plane aspects, removing simulation results and architectural considerations
beyond the forwarding plane.</t>

<t>It also proposes one then considered to be interesting alternative to the encoding. Instead of
discarding unnecessary parts of the tree structure for every copy of a packet made along the
tree, its forwarding machinery instead uses two offset pointers in the header to point to the
relevant sub-structure for the next-hop, so that only a rewrite of these two pointers is needed.
This replicates the offset-rewrite used in unicast source-routing headers such as in IP,
<xref target="RFC791"/>, or IPv6, <xref target="RFC6554"/> and <xref target="RFC8754"/>.</t>

<t>Discussions about discarding vs. changing of offset since then seems to indicate that changing
offsets may be beneficial for forwarders that can save memory bandwidth when not having to rewrite
complete packet headers, such as specifically systems with so-called scatter-gather I/O,
whereas discarding of data is more beneficial when forwards do have an equivalent of
scatter/gather I/O, something which all modern high-speed routers seem to have, including
the Tofino platform used for validation of the approach described in this document.</t>

</section>
<section anchor="encapsulations-for-ipv6-only-networks"><name>Encapsulations for IPv6-only networks</name>

<t>Whereas all initial RBS proposal did either not propose specific encapsulations for
the RBS structure and/or discussed how to use RBS with the existing BIER encapsulation <xref target="RFC8296"/>,
the 2022 <xref target="I-D.xu-msr6-rbs"/> describes the encapsulation of RBS into an IPv6 extension header,
in support of a forwarding plane where all packets on the wire are IPv6 packets, rewriting
per-RBS-hop the destination IPv6 address of the outer IPv6 header like pre-existing
unicast IPv6 stateless source routing solutions too (<xref target="RFC6554"/>, <xref target="RFC8754"/>).</t>

<t>This approach was based on the express preference desire of IPv6 operators to have a common
encapsulation of all packets on the wire for operation reasons ("IPv6 only network design") and to share
a common source-routing mechanism operating on the principle of per-steering-hop IPv6
destination address rewrite.</t>

<t><xref target="I-D.eckert-msr6-rbs"/> extends this approach by adding the offset-pointer rewrite of
<xref target="I-D.eckert-bier-rbs"/> to the extension header to avoid any change in length of the
extension header, but it also includes another, RBS indepent field, the IPv6 multicast
destination address to the extension header. Only this aditional would allow for RBS
with a single extension header to be a complete IPv6 multicast source-routing solution.
BIER/BIER-TE or any encapsulation variations of RBS without such a header field would
always require to carry a full IPv6 header as a payload to provie end-to-end IPv6 multicast
service to applications.</t>

</section>
</section>

    <section anchor="contributors" numbered="false" toc="include" removeInRFC="false">
        <name>Contributors</name>
    <contact initials="X." surname="Geng" fullname="Xuesong Geng">
      <organization>Huawei</organization>
      <address>
        <postal>
          <country>China</country>
        </postal>
        <email>gengxuesong@huawei.com</email>
      </address>
    </contact>
    <contact initials="X." surname="Zheng" fullname="Xiuli Zheng">
      <organization>Huawei</organization>
      <address>
        <postal>
          <country>China</country>
        </postal>
        <email>zhengxiuli@huawei.com</email>
      </address>
    </contact>
    <contact initials="R." surname="Meng" fullname="Rui Meng">
      <organization>Huawei</organization>
      <address>
        <postal>
          <country>China</country>
        </postal>
        <email>mengrui@huawei.com</email>
      </address>
    </contact>
    <contact initials="F." surname="Li" fullname="Fengkai Li">
      <organization>Huawei</organization>
      <address>
        <postal>
          <country>China</country>
        </postal>
        <email>lifengkai@huawei.com</email>
      </address>
    </contact>
    </section>

  </back>

<!-- ##markdown-source:
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
xY7XMjMmkQqzhmVViwH8J7ePxX2FAMbraB2HwHK3soJL1vRWOxQ6oeBKzE69
MLwqRfELjEw1NSt69eZOrTml21FkyeFym02GjV0CcXNxx7xiC00upx3Ey2kb
GL7l292MEbn/ktuiDKmX0rioduEeQE8XpMc7vvwLipD5iQ4cspgpgsYtZ+DD
ox9YIzvyxwiNnrSk4PwUBGtyDzxXWeFY4RKma7miAIiN/XOxOkMauaq0FDZU
3nF3ozQbGd2VxSpYBwapOQOlyRNPEckYczUq+8tmRcM6krONNuS9Y+xQ0+Y9
qYOUdIp0ICSxusIrehur1ieuDfYDhroPaf+ERGVuCiK/igRPbK6nXPweJRzt
DuGN+VierqKmTkFcK4In19m2ajnHIYnlrpu/ws4TovyfyVCfH/d6zjS013BL
wG62tzif1jgYQnwmZJJH/ygXKWU1utXoemBFHGR10UPEXaDGk0c7o0dNRpup
we6MexWxjiI/TSX+MaO8b6Qt1q7ndhb7r1QLe7ZD/0TTRolX3Zs403GLM9Q7
vZd4k3STHpJjLyac3JuEW5oD4EntCJhr3DTFwt9HJQMkU248GyH9Vxu5ZVLX
l+2Jt4SZ+XprHc3xlbbBc0lX3kQV3qQDqVeU3kcFUBeaBmore0k6gKwEUiow
BprI+jaX600Dc1HHoqln9s0KRetDXA2wprOrrD1//vrFePyADO5t64z5OtdW
hJyOFNTTjgD5ZzxRvgaS9ZAghMIOQSea/oKYhpYG32RNDAZwniw9Th5vuhH6
PlfF4v3dm3o7F18LFS+w3KZcKZB8W6vxddSDJnDx2GM9yidOc9XPjW8PgaYN
vVDJxLvIQditXCh8YHgAs+hUvapfgbLckaNWYPDiEpo70DzW1N1aSyRFcQJC
qerWibaNaHK7rFZ0p+7sLZbq5kTsTUvN3LHMAassa1VP+XrsUHEYVuvlhgM8
TgqJyi0j4VGsD4kJ8M0W6VVLBFQHYg2SW6WRKpSV2gEr1QFQGAelJKYw7mAN
oAPe7M6FmZqyhtvDOvxoPFh5o9YpQyVVviiwrK29HYUKyFUu5QtZY0QJWa87
dIz3h+ecusliLy0S/upkcl8u9qgLmkSU+jDAAkWvkGGaAqEuQfYMmeRlDDhj
Hz0OBhFKr5JbRBNGimBZbJFF3IrGL1Cuava6a+QGtLQ1eRd37q0iwBwrKQTv
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
AA==

-->

</rfc>

